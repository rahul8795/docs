Need of Collections:
---------------------
--> An array is an indexed Collection of fixed number of homogeneous data elements.
--> The main advantage of Arrays is we can represent multople values with a single
    variable. So that reusability of the code will be improved.

Limitations of Object type  Arrays:
------------------------------------
1. Arrays are fixed in size i.e. once we created an array with some size there is no chance 
   of incresing or decreasing it's size based on our requirement. Hence to use arrays 
   compulsory we shhould know the size in advance which not possible always.
2. Arrays can hold only homogeneous data elements.
Ex:-
Student[] s = new Student[10000];
s[0] = new Student(); Correct
s[1] = new Customer(); wrong

But we can resolve this problem by using objects arrays.
Object [] o = new Object[10000];
o[0] = new Student(); Correct
o[1] = new Customer(); Correct

3. Array concept is not based on some standard data structure hence readymade method support is 
   not available for evey requirement we have to write the code explicitly. Which is complexity 
   of programming.

To overcome the above limotations of Arrays we should go for Collections.

--> Collections are growbalble in nature. i.e. based on our requirement we can increse or decerease
    the size.
--> Collections can hold both homogeneous and Heterogeneous elements.
--> Every collection class is implemented based on some standard data structure, Hence readymade method
    is support available for every requirement. Being a programmer we have to use this method and we are
    not responsible to provide imolementaion.

Difference between Arrays and Collections:
-------------------------------------------
1) Arrays are fixed in size.
   Collections are qrowable in nature.i.e based on our qequirement we can increase or decrease the size.

2) WRT memory arrays are not recommended to use.
   WRT memory collecitons are recommended to use.

3) WRT performance Arrays are recommended to use.
   WRT performance collecitons are not recommended to use.

4) Arrays can hold only homogeneous datatype elements.
   Collecitons can hold both homogeneous and heterogeneous elements.

5) There are no underlying data structure for arrays and hence readymade method support is not available.
   Every collections class is implemented based on some standard data strucutre. Hence readymade method 
   support is availbale for every requirement.

6) Array can hold both primitives and object types.
   Collecitons can hold only objects but not primitives.

Collection and Collection Framework:
--------------------------------------
Collection:
----------
If we want to represent a group of individual objects as Single entity then we shoud go for Colleciton.

Collection Framework:
----------------------  
If defiens several classes and interface which can be used a group of objects as single entity.

Note: In java - Collection,Collection Framework
      In C++  - Container, STL(Standard Template Library)


9 key intefaces of Collection Framework:
-----------------------------------------
1) Collection(I):
-----------------
   .) If we want to represent a group of individual object as a single entity then we should go for Collection.
   .) Colection interface defines the most common methods which are applicable for any Collection object.
   .) In general colleciton interface is considered as root interface of Collection Framework.

Note: There is no concrete class which implements collection interface directly.

Differecne between Collcetion and Collecitons:
------------------------------------------------
--> Collection is an interface which can be used to represent a group of individual objects as a single entity.
    Collectiosn is an utility class present in java.util.package to define several utility methods (like Sorting, Searching,...) 
    for Collection objects.

2) List(I):
------------
--> List is child interface of Collection.
--> If we want to represent a group of individual objects as a single entity where duplicates are allowed and insertion order 
    preserved then we should go for List.

Collection(1.2v)
  ---List(1.2v)
        ----ArrayList(1.2v)
        ----LinkedList(1.2v)
        ----Vector(1.0v)
               --------Stack(1.0v)

Note: Vector and Stack classes are re-engineer in 1.2v to implement list interface.

3) Set(I):
----------
--> It is the child interface of Collection.
--> If we want to represent a group of individual objects as a single entity where duplicates are not allowed and insertion order
    not preserved then we sholud go for Set.

Collection(1.2v)
------Set(1.2v)
      ---HashSet(1.2v)
           -----LinkedHashSet(1.4)

Difference between List and Set:
----------------------------------
1) List- Duplicates are allowed
         Insertion order preserved
   Set - Duplicates are not allowed
         Insertion order not preserved


4) Sorted Set(I):
------------------
--> It is child interface of Set.
--> If we want to represent a group of individual objects as a single entity where duplicates are not allowed but all objects
    should be inserted according to some sorting order then we should go for SortedSet.

5) Navigable Set(I):
---------------------
--> It is child interface of SortedSet it defines several methods for navigation purpose.

Collection(1.2v)
------Set(1.2v)
       ------SortedSet(1.2v)
             -------NavigableSet(1.6v)
                   -----------TreeSet(1.2v)


6) Queue:
---------
--> It is child interface of Collection.
--> If we want to represent a group of individual objects prior to processing then we should go for Queue.

Ex. before sending a mail all mail id's we have to store somewhere and in which order we saved in the same order mail's should be delivered
    in which order we saved in the same order mail's should be delivered(First in First Out) for this requirement Queue concept is the best
    choice.

Collection(1.2v)
-----Queue(1.5v)
     -----PriorityQueue(1.5v)
     -----BlockingQueue(1.5v)
             -------LinkedBlockingQueue(1.5v)
             -------PriorityBlockingQueue(1.5v)

Note:
--> All the above interface(Collection,List,Set,SortedSet,NavigableSet and Queue) meant for representing a group of individual objects.
--> If we want to represent a group of objects as key value pairs then we should go for Map inteface.

7) Map:
---------
--> Map is not the child interface of Collection.
--> If we want to represent a group of individual objects as key value pairs then should go for Map.
Ex.  Roll No     Name
     101         Durga
     102         Ravi
     103         Venkat

Both key and value are objects, duplicated keys are not allowed but values can be duplicated.


Map(1.2v)
---HashMap(1.2v)
   ---LinkedHashMap(1.0v)
---WeakHashMap(1.2v)
---IdentityHashMap(1.4v)
-Dictionary(1.0v)(Absract Class)
---Hashtable(1.0v)
   ---Properties(1.0v)

8) SortedMap:
---------------
--> It is child interface of map.
--> If we want to represent a group of key value pairs according to some sorting order of keys then we should go for SortedMap

Map(1.2v)
----SortedMap(1.2v)

9) NavigableMap:
-----------------
--> It is child interface of SortedMap, it defines several utility methods for navigation purpose.

Map(1.2v)
-----SortedMap(1.2v)
     -----NavigableMap(1.2v)
           ------TreeMap(1.2v)


Collection Inteface:
---------------------
--> If we want to represent a group of individual objects as a single entity then we should go for Collection.
--> In general collection interface is considered as root interface on Collection Framework.
--> Collection interface defines the most common methods which are applicable for any colletion object.

Important methods of Collection Interface:
------------------------------------------
boolean add(Object o)
boolean addAll(Collection c)
boolean remove(Object o)
boolean removeAll(Collection c)
boolean reatainAll(Collection c)
void clear()
boolean contains(Object o)
boolean (Collection c)
boolean isEmpty()
int size()
Obejct[] toArray()
Itertor iterator()

Note: Collection interface doesn't contain any method to retrieve objects there is no concrete class which implements
      colleciton class directly.

List Interface:
---------------
--> It is child interface of Collection.
--> If we want to represent a group of individual objects as a single entity where duplicates are allowed and insertion
    order must be preserved tehn we should go for List.
--> We can differentiate duplicates by using index.
--> We can preserve insertion order by using index,hence index play very important role in list interface.

List interface specific methods:
---------------------------------
void add(int index, Object o)
boolean addAll(int index,Collectionc)
object get(int index)
object remove(int index)
object set(int index, Object new)
int indexOf(Object o)
int lastIndexOf(Object o)
ListIterator listIterator()


ArrayList Class:
-----------
--> The underlined data structure resizable Array or Growable Array
--> Duplicates are allowed
--> Insertion Order is preserved
--> Heterogeneous objects are allowed [except TreeSet and TreeMap everywhere hetrogeneous objects are allowed].
--> Null insertion is possible. 

ArrayList Constructors:
------------------------
1. ArrayList al = new ArrayList()
   Creates an emplty Arraylist object with default initial capacity 10.
   Once ArrayList reaches its map capacity a new ArrayList will be created with new capacity = (currentcapacity * 3/2)+1.

2. ArrayList al = new ArrayList(int initialCapacity);

3. ArrayList al = new ArrayList(Collection c);

Example:
import java.util.*;
Class ArrayListDemo{
  public static void main(String[] args) { 
     ArrayList l = new ArrayList();
     l.add("A");
     l.add(10);
     l.add(null);
     l.add("A");
     sopn(l); //[A,10,null,A]
     l.add("2","m");
     l.add("N");
     sopln(l); // [A,10,m,A,N]
  }
}


Note:
--> Usually we can use Collections to hold and transfer Objects from one place to another place, to provide support for this 
    requirement every Collection already implements Serializable and Cloneable interfaces.
--> ArrayList and Vector classes implements RandomAccess interface so that we can access any Random elements with the same speed.
--> Hence if our frequent operation is retrival operation then ArrayList is the best choice.

RandomAccess:
--> Present in java.util package.
--> It doesn't contain any methods and it is a Marker interface.

Ex:
---
ArrayList l1 = new ArrayList();
LinkedList l2 = new LinkedList();
sopln(l1 instanceOf Serializable); //true
sopln(l2 instanceOf Cloneable); //true
sopln(l1 instanceOf RandomAccess); //true
sopln(l2 instanceOf RandomAccess); //false

when to use aaraylist:
----------------------
--> ArrayList is best choice if our frequent operation is retrival operation (Because ArrayList implements RandomAccess interfaces)
--> ArracyList is the worst choice if our frequent operation is insertion or deletion in the middle (Because several shift operation
    are require)

Difference Between ArrayList and vector:
-----------------------------------------
--> Every method present in Arraylist is non synchronize
    Every method present in vector is synchronize

--> At a time multiple thread are allowed to operate on ArrayList Object and hence ArrayList is not thread safe
    At a time only one thread is allowed to operate on Vector, object is thread safe

--> Threds are not required to wait to operate on ArrayList, hence relatively performance is high.
    Threds are required to wait to operate on Vector object and hence relatively performance is low.

--> Introduced in 1.2 version and it is non legacy class(ArrayList)
    Introduced in 1.0 version and it is a legacy class(Vector)


How to get Synchronized version of Arraylist:
-----------------------------------------------
--> By default ArrayList is Object is non-synchronized but we can get synchronized version of ArrayList by using Collection class
    syschronizedList() method.
 
    public static List synchronizedList(List l)

    Non-Synchronized
      ArrayList l1 = new ArrayList();
   
    Synchronized
      List l = Collections.synchronizedList(l1);

--> Similarly we can get Synchronized version of Set, Map Objects by using the following methods of Collection class.
     
    public static Set synchronizedSet(Set s);
    public static Set SynchronizedMap(Map m); 


LinkedList Class:
------------
--> The underlying data structure is Double Linked List.
--> Insertion order is preserved.
--> Duplicates are allowed.
--> Heterogeneous Objects are allowed.
--> Null isertion is possible.
--> LinkedList implements Serializable and Cloneable inteface but not RandomAccess inteface.
--> LinkedList is the best choice if our frequent operation is insertion or deletion in the middle.
--> LinkedList is the worst choice if our frequent operation is retrival opearion.

--> Usually we can use LinkedList to implement stacks and queues to provide support for this requirement LinkedList class
    defines following specific methods.

   a) void addFirst();
   b) void addLast();
   c) Object getFirst();
   d) Object getLast();
   e) Object removeFirst();
   f) Object removeLast();

Construtor:
-----------
1) LinkedList l = new LinkedList();

--> Create an empty LinkedList Object

2) LinkedList l = new LinkedList(Collection c);

--> Creates an equivalent LinkedList Object for the given Collection


Ex. 
----
import java.util.*;

class LinkedListDemo {
  pblic static void main(String[] args) {
    LinkedList l = new LinkedList();
    l.add("durga");
    l.add(30);
    l.add(null);
    l.add("durga");
    l.set(0,"software");
    l.add(0,"venkey");
    l.addFirst("ccc");
    sopln(l);//[ccc,venkey,software,30,null]

  }
}

Difference between LinkedList and AraryList:
----------------------------------------------
--> ArrayList is the best choice if our frequent operation is retrival
    LinkedList is the best choice if our frequent operation is insertion
    deletion

--> ArrayList is the worst choice if our frequent operation is insertion 
    or deletion
    LinkedList is the worst choice if our frequent operation is retrieval
    operation

--> Underlying data structure for ArrayList is resizable or growable array.
    Underlyinh data structure is Double Linked List.

--> AraryList implements RandomAccess interface
    LinkedList doesn't implement RandomAccess interface


Vector Class:
--------------
--> The underlying data structure for the vectoe is resizable array or growabel array
--> Duplicate objects are allowed
--> Insertion order are preserved
--> 'null' insertion is possible
--> Heterogeneous objects are allowed
--> Vector class implemented Serializable, Cloneable and RandomAccess Interfaces.
--> Most of the methods present in vector are synchronized. Hence Vector object is Thread-safe.
--> Best choice if the frequent operation is retrival.
   
Specific Methods:
-----------------
For adding objects:
  
  add(Object o)             [From Collection -List(I)]
  add(int index, Object o)  [From List]
  addElement(Object o)      [From Vector]

For removing objects:
  
  Remove(Object o)          [From Collection]
  removeElement(Object o)   [From Vector]
  remove(int index)         [From List]
  RemoveElementAt(int index)[From Vector]
  clear()                   [From Collection]
  removeAllElements()       [From Vector]

For Accessing Elements:

  Obejct get(int index)      [From Collection]
  Object elementAr(int index)[From Vector]
  Object firstElement()      [From Vector]
  Object lastElement()       [From Vector]

Other Methods:
    
   int size();
   int capacity()'
   Enumeration elements();

Constructor:

1) Vector v = new Vector();

--> Create an empty vector object with default initial capacity 10,
    once vector reaches it's max capacity a new vector Object will be
    Created with new capacity = 2 * current capacity

2) Vector v = new Vector(int initialCapacity);

--> Creates an empty Vector Object with specified initial capacity

3) Vector v = new Vector(int initialCapacity, int increamentalCapacity);

4) Vector v = new Vector(Collection c);

--> Creates an equivalent Vector Object for the given Collection

Ex:
----
import java.util.*;
class VectorDemo {
  public static void main(String arg[]) {
    Vector v = new Vector();
    sopln(v.capacity()); //[10]
    for(int i = 0; i<10; i++){
      v.addElement(i);
    }
    sopln(v.capacity()); //[10]
    v.addElement("A");
    sopln(v.capacity()); //[20]
    sopln(v); [0,1,2,3,4,5,6,7,8,9,A]
  }
}

Stack Class:
-------------
--> It is a child class of Vector
--> Is is specially designed class for Last In First Out order(LIFO)

Constructor:
------------
   Stack s = new Stack();

Stack methods:
--------------
1) Object push(Object obj);
   - For inserting an object to the stack

2) Object pop();
   - To removes and returns top of the stack

3) Object peak();
   - To returns the top of the stack without removal of object

4) int search(Object obj);
   - If the specified object is available it returns its offset from top of 
     the stack.
   - If the object is not available then it returns -1

5) Object pop();
   - For inserting an object to the stack

Ex:
----
import java.utli.*;
class StackDemo {
  public static void main(String[] args) {
    Stack s = new Stack();
    s.push("A");
    s.push("B");
    s.push("C");
    sopln(s); //[A,B,C]
    sopln(s.search("A"));  //[3]
    sopln(s.search("X"));  //[-1]
  }
}

Three Cursors of Java:
-----------------------
--> If we want to retrieve Objects one by one from the Collection, then we should go for Cursors.
--> There are three types of cursors are available in java.
1) Enumeration
2) Iterator
3) ListIterator

1) Enumeration:
---------------
--> Introduced in 1.0 version(for lagacy0.
--> We can use Enumeration to get Objects one by one from the old Colletion Objects(Legacy Collections).
--> we can create Enumeration Object by using elements() method of Vector class.
     public Enumeratin elements();
Ex:
----
  Enumeration e = v.elements();

--> Enumeration defines the following two methods:
   - public boolean hasMoreElemetns();
   - public Object nextElement();

Ex:
----
import java.util.*;
class EnumerationDemo{
  public static void main(String[] args) {
    Vector v = new Vector();
    for(int i=0; i<=10; i++) {
       v.addElement(i);
    }
    sopln(v); //[0,1,2,3,4,5,6,7,8,9,10\
    Enumeration e = v.elements();
    while(e.hasMoreElements()) {
     Integer i = (Integer) e.nextElement();
     if((i%2)===0) 
       sopln(i);  //[0,2,4,6,8,10]
    }
  }
}


Limitation of Enumeration:
---------------------------
--> Enumeration concept is applicable only for lagacy classes and hence it is not a universal cursor.
--> By using Enumeration we can get only read access and we can't perform remove operation.

Note: To overcome above limitations of Enumeration we should go for Iterator.

2) Iterator:
-------------
--> We can apply Iterator concept for any Collection object hence it is universal cursor.
--> By using Iterator we can perform both read and remove operations.
--> We can create Iterator Object by using iterator() method of Collection interface.
     public Iterator iterator();

Ex:
---
   Iterator itr = C.iterator();
   - where C is any Collection Object

Methods in Iterator:
---------------------
--> Iterator interface defines the follwing three methods.
    1. public boolean hasNext()
    2. public Object next()
    3. public void remove()

Ex:
---
import java.util.*;
class IteratorDemo {
  public static void main(String[] args) {
    ArrayList l = new ArrayList();
    for(int i=0; i<=10; i++) {
     l.add(i);
    }
    sopln(l); // [0,1,2,3,4,5,6,7,8,9,10]
    Iterator itr = l.iterator();
    while(itr.hasNext()) {
      Integer i = (Integer)itr.next();
      if((i%2)==0)
       sopln(i); //0,2,4,6,8,10
      else
       itr.remove();
    } 
    sopln(l); //0,2,4,6,8,10
  }
}

limitation of Iterator:
------------------------
1) By using Enumeration and Iterator we can move only towards forward direction
   and we can't move to the backward direction, and hence these are single 
   direction cursors.
2) By using Iterator we can perform only read and remove operations and we can't 
   perform replacement of new Objects.

Note: To overcome above limitaions of Iterator we should go for ListIterator.


3) ListIterator:
----------------
--> By using ListIterator we can move either to the forward direciton or to the 
    backward direction, and hence ListIterator is biderectional cursor.
--> By using ListInterator we can perform replacement and addition of new Objects
    in addition to read and remove operations.
--> We can create ListIterator Object by using listIterator() method of List interface.
    public ListIterator listIterator();

Ex:
---
      ListIterator itr = l.listIterator();
      - where l is any List Object

Methods in ListIterator:
-------------------------
--> ListIterator is the child interface of Iterator and hence all methods of Iterator by
    default available to ListIterator.
--> ListIterator Interface defines the following 9 methods
   -forward direction 
    1) public boolean hasNext()
    2) public void next()
    3) public int nextIndex()
   -backward direction 
    4) public boolean hasPrevious()
    5) public void Previous()
    6) public int previousIndex()
   -other capacity methods
    7) public void remove()
    8) public void set(Object new)
    9) public void add(Object new)


Ex:
---
import java.util.*;
class ListIteratorDemo {
  public static void main(String[] args) {
   LinkedList l = new LinkedList();
   l.add("Bala");
   l.add("venkey");
   l.add("chiru");
   l.add("nag")l;
   sopln(l); //[Bala,venkey,chiru,nag]
   ListIterator itr = l.listIterator();
   while(itr.hasNext()){
     String s = (String)itr.next();
     if(s.equals("venkey")){
        itr.remove();
     }
     else if(s.equals("nag")){
        itr.add("chaitu");
     }
     else if(s.equals("chiru")){
        itr.set("charan");
     }
     sopln(l); //[Bala,charan,nag,chaitu]

   }
  }
}
Note: ListIterator is the most powerful cursor but its limitation is, it is
      applicable only for List implemented class objects and it is not a 
      universal cursor.

Comparison of the three Cursors of Java:
-----------------------------------------

  Properties       |  Enumeration    |   Iterator            |    ListIterator
--------------------------------------------------------------------------------------------------------------
1) Applicable for  |Only legacy class|Any Collection classes |Only List classes               
2) Movement        |Only forward     |Only forward direction |Both forward and backward 
                   |direction(single |(single direction)     |direction(biderectional
                   |direction)       |                       |
3) Accessability   |Only read access |Both read and remove   |Read,Remove,replace and addition of new objects
4) How to get it?  |By using elemetns|Bt using iterator() met|By using listIterator() method of List interface
                   |() method of vect|od of collection interf|
                   |or class         |ace                    | 
5) methods         |2 methods        |3 methods              |9 methods
                   |hasMoreElement() |hasNext()              |
                   |nextElement()    |next()                 |
                   |                 |remove()               |
6) Is it legacy?   |"yes"(1.0v)      |"no"(1.2v)             |"no"(1.2v)

Implementaion Classes of the three Cursor of java:
---------------------------------------------------
import java.util.*;
class CursorDemo{ 
  public static void main(String[] args){
    Vector v = new Vector();
    Enumeration e = v.element();
    Iterator itr = v.iterator();
    ListIterator ltr = v.listIterator();
    sopln(e.getClass().getName()); // java.util.Vector$1
    sopln(itr.getClass().getName()); // java.util.Vector$ltr
    sopln(ltr.getClass().getName()); //java.util.Vector$ListLtr
  }
}


HashSet:
--------
Collection(1.2v)
----Set(1.2v)
    ---HashSet(1.2v) 
       ----LinkedHashSet(1.4v)
    ---SortedSet(1.2v)
        ----NavigableSet(1.6v)
             ----TreeSet(1.2)

--> Set is child interface of Collection
--> If we want to represent a group of individual objects as a single
    entity, where duplicates are not allowed and insertion order is not 
    preserved then we should go for Set.
--> Set interface doesn't contain any new methods. So we have to use only
    Collection interface methods.

HashSet:
--------
--> Underlying data structure is HashTable.
--> Duplicates are not allowed. If we are trying to insert duplicates, we
    won't get any compiletime or runtime errors. add() method simply return
    false.
--> Insertion order is not preserved and all objects will be inserted based
    on hash-code of objects.
--> Heterogeneous objects are allowed.
--> "null" insertion is possible
--> implements Serializable and cloneable interface but not RandomAccess
--> HashSet is the best choice, if our frequent is Search operation

Construtors:
-------------
1) HashSet h = new HashSet();
  -Creates an empty HashSet object with default initial capacity 16 & default 
   fill ratio(load factor) 0.75

2) HashSet h = new HashSet(int initialCapacity);
   -Creates an empty HashSet object with specified initial capacity & default 
    fill ratio 0.75

3) HashSet h = new HashSet(int initialCapacity,float loadFactor);
   -Creates an empty HashSet object wuth specified initial capacity & specified
    load factor (or fill ratio)

4) HashSet h = new HashSet(Collection c);
   -for inter conversion between collection obejcts.

Load Factor / Fill Ratio:
-------------------------
--> After loading the how much factor, a new HashSet object will be created, that
    factor is calles as load factor or fill ratio.

Ex:
---
import java.util.*;
class HashSetDemo {
  public static void main(String[] args){
    HashSet h = new HashSet();
    h.add("B");
    h.add("C");
    h.add("D");
    h.add("Z");
    h.add(null);
    h.add(10);
    sopln(h.add("Z")); // false
    sopln(h);//[null,D,B,C,10,Z]
  }
}
  

LinkedHashSet:
--------------- 
--> It is the child class of HashSet.
--> Introduced in 1.4 version
--> It is exactly same as HashSet except the following difference:
    - HashSet underlying data structure is Hash Table
      LinkedHashSet underlying data structure is Hash Table + Linked List
      (that is hybrid data structure)
    - Insertion order is not preserved-HashSet
      Insertion order is preserved-LinkedHashSet
    - Introduced in 1.2 version-HashSet
      Introdudced in 1.4 version- LinkedHashSet


Ex:
----
import java.util.*;
class HashSetDemo {
  public static void main(String[] args){
    LinkedHashSet h = new LinkedHashSet();
    h.add("B");
    h.add("C");
    h.add("D");
    h.add("Z");
    h.add(null);
    h.add(10);
    sopln(h.add("Z")); // false
    sopln(h);//[B,C,D,Z,null,10]
  }
}

Note: LinkedHashSet is the best choice to develop cache based applications,
      where duplicates are not allowed and isnertion order must be preserved.


SortedSet:
-----------
--> It is child interface of set.
--> If we want to represent a group of inidividual objects according to some 
    sorting order and dupicates are not allowed then we should go for SortedSet.

Specific Methods:
------------------
1) Object first() - returns first element of the SortedSet

2) Object last() - returns last element of the SortedSet

3) SortedSet headSet(Object obj) - returns the SortedSet whose element are < obj

4) SortedSet tailSet(Object obj) - returns the SortedSet whose element are >= obj

5) SortedSet subSet(Object obj1, Object obj2) - return the SortedSet whose element are >= obj1 and <obj2

6) Comparator comparator() -
      returns Comparator object that describes underlying sorting technique.
      if we are using default natural sorting order then we will get null.

Ex:
----
{100,101,103,104,107,110,115}

1. first()        -> 100
2. last()         -> 115
3. headSet(104)   -> [100,101,103]
4. tailSet(104)   -> [104,107,110,115]
5. subSet(103,110)-> [103,104,107]
6. Comparator()   -> null

Note:
1) Default natural sorting order for numbers Ascending order and for String alphabetical order.
2) We can apply the above methods only on SortedSet implemented class objects. That is on the 
   TreeSet object.

TreeSet:
--------
1. The underlying data structure for TreeSet is Balanced Tree.
2. Dupicates objects are not allowed.
3. Insertion order not preserved, but all objects will be inserted according to some sorting order.
4. Heterogeneous objects are not allowed. If we are trying to insert heterogeneous objects then we
   will get runtime exception saying ClassCastException.
5. Null Insertion is allowed, but only once.

Constructors:
--------------
1. TreeSet t = new TreeSet();
   - Creates an empty TreeSet object where elements will be inseted according to default natural order.

2. TreeSet t = new TreeSet(Comparator c);
   - Creates an empty TreeSet Object where elements will be inserted according to customized sorting order.

3. TreeSet t = new TreeSet(Collection c);

4. TreeSet t = new TreeSet(SortedSet s);

Ex:
----
import java.util.*;
class TreeSetDemo {
  public static void main(String[] args) {
    TreeSet t = new TreeSet();
    t.add("A");
    t.add("a");
    t.add("B");
    t.add("Z");
    t.add("L");
    //t.add(new Integer(10)); //ClassCastException
    //t.add(null); //NullPointerException 
    sopln(t); // [A,B,L,Z,a]
  }
}

Null Acceptance:
----------------
1) For empty TreeSet as the first element null insetion is possible.
   But after inserting that null if we are trying to insert any another 
   element we will get NullPointerException.
2) For Non empty TreeSet if we are trying to insert Null then we will get 
   NullPointerException.     


Ex:
----
import java.util.*;
class TreeSetDemo1 {
  public static void main(String[] args) {
    TreeSet t = new TreeSet();
    t.add(new StringBuffer("A"));
    t.add(new StringBuffer("B"));
    t.add(new StringBuffer("Z"));
    t.add(new StringBuffer("L"));
    sopln(t); // ClassCastException
  }
}

Note:
1. If we are depending on default natural sorting order then objects should be 
   homogeneous and comparable. Otherwise we will get runtime exception saying
   ClassCastException.
2. An object is said to be comparable if and only if the corresponding class
   implemnets java.lang.comparable interface.
3. String class and all wrapper classes already implemets comparable interface.
   But StringBuffer doesn't implement comparable interface.
  -- Hence in the above program we got ClassCastException--

Comparable Interface(I):
------------------------
--> This interface present in java.lang package it contains only one method CompareTo().
     public int ComapreTo(Onject obj)

Ex:
---
obj1.CompareTo(obj2)
  |-> returns -ve iff obj1 has to come before obj2
  |-> returns +ve iff obj1 has to come after obj2
  |-> retruns 0 iff obj1 and obj2 are equal.

Ex:
---
class Test{
  public static void main(String[] args) {
    sopln("A".compareTo("Z")); //-ve
    sopln("Z".compareTo("B")); //+ve
    sopln("A".compareTo("A")); //0
    sopln("A".compareTo(null)); //NullPointerException (NPE)
  }
}


Note: 
1) If we depending on default natural sorting order internally JVM will call compareTo() 
   method will inserting objects to the TreeSet. Hence the objects should be comparable.
    
    TreeSet t = new TreeSet();
    t.add("B");
    t.add("Z"); //"Z".comapreTo("B"); +ve
    t.add("A"); //"A".compareTo("B"); -ve
    sopln(t);  //[A,B,Z]

2) If we are not satisfied with default natural sorting order or if the default natural order
   is not already available then we can define our own customized sorting by using comparator.

3) Comparable ment for default natural sorting order where as comparator ment for customized
   sorting order.

Comparator Interface:
---------------------
--> We can use comparator to define our own sorting(Customized sorting)
--> Comparator interface present in java.util package.
--> It defines two methods, compare and equals
    1. public int compare(Object obj1, Object obj2)
       |-> returns -ve iff obj1 has to come before obj2
       |-> returns +ve iff obj1 has to come after obj2
       |-> retruns 0 iff obj1 and obj2 are equal

    2. public boolean equals();

--> When ever we are implementing Comparator interface, compulsory we should provide implement
    for compare() method.
--> And implementing equals() method is optional, because it is already available in evey java
    class from Object class through inheritacne.

Ex:
----
imort java.util.*;
class TreeSetDemo3{
  public static void main(String[] args){
    TreeSet t = new TreeSet(new MyComparator())l
    t.add(10);
    t.add(0);
    t.add(15);
    t.add(20);
    t.add(20);
    sopln(t);
  }
}
class MyComparator implemetns Comparator {
  public int compare(Object obj1, Object obj2) {
    Integer i1 = (Interger)obj1;
    Integer i2 = (Interger)obj2;
    if(i1<i2) 
     return +1;
    else if(i1>i2)
      return -1;
    else
      return 0;
  }
}

Integer Objects Into TreeSet, Descending order:
-----------------------------------------------

    TreeSet t = new TreeSet(new MyComparator())l
    t.add(10);
    t.add(0);   ---- +ve ---> compare(0,10);
    t.add(15);  ---- -ve ---> compare(15,10);

    t.add(20);  ---- +ve ---> compare(20,10);
    t.add(20);  ---- -ve ---> compare(20,15);

    t.add(20);  ---- +ve ---> compare(20,10);
    t.add(20);  ---- -ve ---> compare(20,15);
    t.add(20);  ---- 0 ---> compare(20,20);
    sopln(t);  //[20,15,10,0]

--> At line-1 if we are not passing comparator object then internally JVM
    will call CompareTo() method which meant for defult natural sorting order
    (ascenfing order).
    In this case output is [0,10,15,20]

--> If we are passing comparator object at line1 then internally JVM will 
    call compare() method which is meant for customized sorting.(Descending order)
    In this case output is [20,15,10,0]


Various possible implementaion of comapre() method:
----------------------------------------------------

class MyComparator implemetns Comparator {
  public int compare(Object obj1, Object obj2) {
    Integer i1 = (Interger)obj1;
    Integer i2 = (Interger)obj2;
    // return i1.compareTo(i2);    [0,10,15,20] ascending order
    // return -i1.compareTo(i2);   [20,15,10,0] descending order
    // return i2.compareTo(i1);    [20,15,10,0] descending order
    // return -i2.compareTo(i1);   [0,10,15,20] ascending order
    // return +1;                  [10,0,15,20,20] Insertion order
    // return -1;                  [20,20,15,0,10] Reverse of insertion order
    //return 0;                    [10]
    (Only first element will be inserted and all the other elements are considered as duplicates)    
  }
}


Ex:
----
imort java.util.*;
class TreeSetDemo4{
  public static void main(String[] args){
    TreeSet t = new TreeSet(new MyComparator())l
    t.add("Roja");
    t.add("ShobhaRani");
    t.add("RajaKumari");
    t.add("GnagaBhavani");
    t.add("Ramulamma");
    sopln(t);
  }
}
class MyComparator implemetns Comparator {
  public int compare(Object obj1, Object obj2) {
    String s1 = obj1.toString();
    String s2 = obj2.toString();
    // return s2.compareTo(s1);
     return -s1.compareTo(s2);
  }
}

Ex:
----
imort java.util.*;
class TreeSetDemo4{
  public static void main(String[] args){
    TreeSet t = new TreeSet(new MyComparator())l
    t.add(new StringBuffer("A"));
    t.add(new StringBuffer("Z"));
    t.add(new StringBuffer("K"));
    t.add(new StringBuffer("L"));
    sopln(t);
  }
}
class MyComparator implemetns Comparator {
  public int compare(Object obj1, Object obj2) {
    String s1 = obj1.toString();
    String s2 = obj2.toString();
    return s1.compareTo(s2);
  }
}

Note: If we are defining our own sorting by comparator, the objects need not be comparable.


Ex:
----
WAP to insert String and StringBuffer objects into the TreeSet where sorting order is increasing length
order if two objects having the same length then consider their alphabetical order>


imort java.util.*;
class TreeSetDemo4{
  public static void main(String[] args){
    TreeSet t = new TreeSet(new MyComparator())l
    t.add("A");
    t.add(new StringBuffer("ABC"));
    t.add(new StringBuffer("AA"));
    t.add("XX");
    t.add("ABCD");
    t.add("A");
    sopln(t);
  }
}
class MyComparator implemetns Comparator {
  public int compare(Object obj1, Object obj2) {
    String s1 = obj1.toString();
    String s2 = obj2.toString();
    int l1 = s1.length();
    int l2 = s2.lnegth();
    if(l1<l2)
      return -1;
    else if(l1>l2)
      return 1;
    else
      return s1.compareTo(s2);
  }
}

Note: 
1) If we are depending on default natural sorting order then objects should be homogeneous
   and comparable otherwise we will get runtime exception saying ClassCastException.
2) But if we are defining our own sorting by comparator then objects need not be homogeneous
   and comparable. We can insert heterogeneous non comparable objects also.


When to use comparable and comparator:
---------------------------------------
1) For predefined Comparable classes like String default natural sorting order already availble.
   If we are not satisfied with that, we can define our own sorting by Comparator object.
2) For predefined non comparible classes like StringBuffer, default natural sorting order is not
   already available. We can define required sorting by implementing Comparator interface.
3) For our own classes like Employee, Student, Customer; the person who is writing our own class,
   he is resoponsible to define default natural sorting order by implementing Comparable interface.
   
   The person who is using our class, if he is not satisfied with default natural sorting order, then
  he can define his own sorting by using Comparator.


Ex:
----
Demo program for cutomized sorting for Employee class:

import java.util.*;

class Employee implements Comparable {
  String name;
  int eid;
  Employee(String name,int eid){
    this.name = name;
    this.eid = eid;
  }
  public String toString() { 
   return name +"-"+eid;
  }
  public int compareTo(Object obj) {
    int eid1 = this.eid;
    Employee e = (Employee)obj;
    int eid2 = e.eid;
    if(eid1<eid2)
      return -1;
    else id(eid1>eid2)
      return 1;
    else 
      return 0;
  
  }
}

class CompCompDemo {
  public static void main(String[] args) {
    Employee e1 = new Employee("nag",100);
    Employee e2 = new Employee("balaiah",200);
    Employee e3 = new Employee("chiru",50);
    Employee e4 = new Employee("venki",150);
    Employee e5 = new Employee("nag",100);
    TreeSet t = new TreeSet();
    t.add(e1);
    t.add(e2);
    t.add(e3);
    t.add(e4);
    t.add(e5);
    sopln(t);
    TreeSet t1 = new TreeSet(new MyComparator);
    t1.add(e1);
    t1.add(e2);
    t1.add(e3);
    t1.add(e4);
    t1.add(e5);
    sopln(t1);
  }
}

class MyComparator implements Comparator {
  public int compare(Object obj1, Object obj2) {
    Employee e1 = (Employee)obj1;
    Employee e2 = (Employee)obj2;
    String s2 = e1.name;
    String s2 = e1.name;
    return s1.compareTo(s2);
  }
}


Differences between Comparable and Comparator:
----------------------------------------------
1) Comparable - It is meant for natural sorting order.
   Comparator - It is meant for customized sorting order.

2) Comparable - Present in java.lang package
   Comparator - Present in java.util package

3) Comparable - This interface defines only one method compareTo()
   Comparator - This interface defiens two methods comapre() and equals()

4) Comparable - all wrapper classes and String class implement comparable interface
   Comparator - The only implemented classes of Comparator are Collator and RuleBasedCollator


Comparision table of Set implemeted classes:
---------------------------------------------

   Property                    HashSet              LinkedHashSet            TreeSet
-------------------------------------------------------------------------------------------
1) underlying data structure | HashTable          | Hashtable + LinkedList  | Balanced Tree
2) Insertion Order           | Not preserved      | preserved               | Not applicable
3) Sorting Order             | Not applicable     | Not applicable          | Applicable
4) Heterogeneous objects     | Allowed            | Allowed                 | Not allowed
5) Duplicates objects        | Not alloed         | Not allowed             | Not allowed
6) Null Acceptance           | Allowed(only once) | Allowed(only once)      | For empty TreeSet as first element Null is allowed and in all other cases we will get NullPointerException




