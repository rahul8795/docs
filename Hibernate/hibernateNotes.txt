Frameworks:
-----------
1. Hibernate
2. Spring
3. Web Services

1. Hibernate:
-------------
--> Hibernate is ORM[Object-Relational Mapping] product/implementaiton/Tool

1. Introduction
    Serialization and Deserialization
    JDBS
    ORM
      ----EJBs-Entity Beans
      ----JPA
      ----Hibernate
              ------
              ------
      Hibernate Arch
      Hibernate Features

2. Steps to prepare Hibernate Applications
    1. POJO class/ Persitence Class
    2. Hibernate Mapping File
    3. Hibernate Configuration File
    4. Client Appl

3. Hibernate Application
   Core Java<-------> Hibernate
   GUI Appl<--------> Hibernate
   Servlets<--------> Hibernate
   JSPs  <----------> Hibernate
   Struts <----------> Hiberante

4. Hibernate Code Generations Tools:
   1. Schema Export
   2. Schema Update
   3. Code Generation

5. Hibernate Primary Key Generation Algorithms.

6. Hibernate Connection Pooling
     Inbuilt Connection Pooling Mechanism
     Third Party vendors provided connection pooing mechanism
          DBCP, Proxool, C3P0
     Web logic Server Provided connection through JNDI Server.

7. Hibernate Transaction Management:
     ACID properties
     Automicity --> Non-Auto-Commit
     Isolation Levels

8. HQL[Hiberanate Query Language]
     from Employee; -------> select *from emp1;

9. Native SQL

10. Criterion API

11. Hibernate Mapping
     1. Basic OR Mapping
     2. Component Mapping
     3. Inheritance Mapping
     4. Associations Mapping

12. Hibernate Filters

13. Cache Mechanism
     I-Cache
     II-cache

14. Hibernate5.x Features

15. JPA Basics


IDE: Eclipse IDE, NetBeans IDE
Databases: Oracle, MySQL


Introduction:
-------------
Enterprise: It is a Business organization or collection of organizations runnig a single
            label.
Enterprise Application: It is a software applicaiton designed for an enterprise to  
simplify the internal Business processing.

To prepare enterprise applicaitons, we have to provide the following three layer.
1. Presentation Layer or user interface layer
--> To improve look and feel to the enterprise appl
--> It is starting point to the appl inorder to access
--> To take data from users and to submit data to appl
--> To perform client side data validations with javascript functions
--> To submit defferent types of requests from client to server Ex. POST, GET, HEAD,....
--> Presentation Logic
--> AWT, SWING, HTML, JSP, Free Marker, Velocity,.....


2. Business processing layer or business layer
--> It is heart of the enterprise application.
--> To define and execute the business rules and regulations which are req by the clients exactly
--> Business Logic
--> Servlet, JSP[Rarely], EJB-Session Beans,...

3. Data layer or Data Storage and access layer or persistence layer
--> To interact with Database and to achieve data persistency
--> Persistence Logic
--> JDBC, EJBs-Entity Beans, JPA, DAOs.....


Hibernate -----> Persistence Layer
Struts, JSF ---> Presentaion Layer
Spring ------> All the enterprise appl layers.

Data Persistency:
------------------
Representing data permanently in back end systems is called as data persistency.

Data persistency Operations: To make data persistency if we perform operations with Back
END Systems then that Operations are called as Data persistence operations.
Ex. CRUD
C ---> Create / Inserting Data
R ---> Read / Retrieve
U ---> Update
D ---> Delete

Data Persistence Tech: To achieve data persistency,if we use any tech then it is called
as Data persistence Tech
EX. JDBC, Hibernate, JPA, EJB-Entity Beans..........

In enterprise applicaitons, to perform data persistency, we will use the following tech
w.r.t JAVa:

1. Serialization and Deserialization
2. JDBC
3. ORM
   1. EJBs Entity Beans
   2. Hibernate
   3. JPA
   4. Open JPA
   5. Toplink
   6. iBatis
      ------
      ------

1. Serialization and Deserialization:
-------------------------------------
The process of seperating data from an object and storing that data in a flat file is 
called as Serialization.

The process of Regenerating an object on the basis of data is called as Deserialization.

1. ObjectOutputStream ---> For Serialization
2. ObjectInputStream ----> For Deserialization

FileOutputStream
FileInputStream  


2. Data Persistency through JDBC:
----------------------------------
--> JDBC is a step by step process or a Tech or an API, it will provide very good env
to interact with databases from Java applications inorder to perform database operations
from java applications.

--> JDBC is an abstraction[Colleciton of interface] provided by SUN Microsystems and 
implemented by all the database vendors.

--> In JDBC applications, we need driver, It will map Java API representaions to SQL
API representations.

Oracle:
Driver Class: oracle.jdbc.OracleDriver
Driver URL: jdbc:oracle:thin:@localhost:1521:xe

MySQL:
Driver Class: com.mysql.cj.jdbc.Driver[MySQL5.7 versions]
              com.mysql.jdbc.Driver[Upto MySQL5.5 version]
Driver URL: jdbc:mysql://localhost:3306/db_Name

Steps tp prepare JDBC Applications:
1. Load and register driver
2. Establish connection between java applicaiton and database.
3. Create either Statement or PreaparedStatement or CallableStatement
4. Write and execute SQL queries
5. Close the resources

Requirement of ORM:
--------------------
ORM is providing mapping between object oriented data model elemetns to relational data
model elemetns either through XML document or through annotaitons

Class --------> Table
Object -------> Record
ID prop ------> OK Column
Normal prop---> Normal Column

Mismatiches between Object Oriented data model and relational data model:
1. Granualarity Mismatch
2. Sub types mismatch
3. Associations Mismatch
4. Identity Mismatch
5. Cost mismatch
   ---------
   ---------

1. Granualarity Mismatch:
------------------------

2. Sub types mismatch:
----------------------
3. Associations Mismatch:
-------------------------
1. One-To-One Association
2. One-To-Many Association
3. Many-To-One Association
4. Many-To-Many Association

By declaring one class reference variable in another class is assocoation.

class Employee{
   String eid;
   String ename;
   String esal;
   String eaddr;
   Account acc;
}

class Account{
   String accNo;
   String accName;
   String accType;
   ----
}

4. Identity Mismatch:
---------------------


ORM
--> Hibernate
--> EJBs - Entity Beans
--> JPA
--> iBatis
--> Open JPA
--> Toplink
     ---------
     --------

Q) To provide data persistency we have already EJBs entity Beans then what is the 
requirement to use Hibernate?
---------------------------------------------------------------------------------------------------------------
Ans:
-----
1. EJBs entity Beans is Heavy Weight Persistency Solutions.
    Hibernate is light weight persistency Solution

2. EJBs Entity Beans must required Application Server Envioronment
    Hibernate applications are executed with or without the application servers.

3. EJBs entity beans is more API dependent.
   Hibernate is less API dependent.

4. EJBs entity beans are not following POJO classes convention.
    HIbernate is following POJO classes convention.
    Note: Plain Old Java Object, it is a normal java bean class, it will not extend or
             implement predefined library.

5. In case of EJBs entity Beans, debugging and testing are very much difficult
   In case of HIbernate, debugging and testing are very simple.

6. EJBs entity beans portability is very less.
    Hibernate portability is more.

7. EJBs entity beans is slower Date persistency mechanism.
    Hibernate is faster data persistency mechanism

8. In EJBs entity beans, one-to-one relations must be required between java classes and 
    database tables.
    In hibernate, it is not mandatory to manage one-to-one association between entiry
    classes and database tables.

9. In case of EJBs entity beans, Bean components are allowed for inheritance directly.
    In case of Hibernate, it is possible to define inheritance relation between bean
    classes as per the requirement.

10. EJBs entity beans is applicable for only Enterprise applications where application
      server environment is exited.
      Hibernate is applicable for both standalone application where application server env
      is not exited and enterprise applications where applicaition server env is exited.

Q) What is the differencr between JPA and Hibernate?
--------------------------------------------------------------------------
Ans:
--------
JPA is an abstraction provided by SUM Microsystems as part of J2EE and it is implemented
by almost all the application servers and it is provding a set of guidlines to
implement ORM rules and regulations.

Hibernate is a direct ORM implemented tool, it has implemented all the ORM
implementations as per JPA gidlines.

Note: Hibernate is having JPA implementaions and ORM implementations 
inorder to manage data persistency.


Hibernate:
--------------
Home: SoftTree
Author: Gavin King
Tool: ORM implementation Tool
Type: Open Source Software
Objective: To simplify Data persistency in Enterprise Applications.
Initial Version: Hibernate1.0[2001]
Use Versions: Hibernate3.x / Hibernate4.x
Latest Version: Hibernate5.x


Hibernate Features:
----------------------------
--> HIbernate is light weight data persistency Mechanism
--> It is following POJO classes convestions.
--> Hibernate is Database independent.
--> Hibernate is able to execute its applications with or without the application
     servers.
--> HIbernate is supported by almost all the servers and IDEs.
--> Hibernate is having very good cache mechanisms.
--> Hibernate is having very good inbuilt connection pooling mechnism.
--> Hibernate is having very good Transactions Support.
--> Hibernate is having very good collections support.
--> Hibernate is having very good annotations support.
--> Hibernate is having Object Oriented, Database Independent and a powerfull query
     language that is "HQL"[Hibernate Query Language].
--> Hibernate is having very good Associations and joins support.
--> Hibernate is having very good mapping support like Inheritance mapping, associations
     mapping......
--> Hibernate is having filters features inoder to filter the results.


Hibernate Arch:
---------------
Hibernate Configuration File:
------------------------------
It is an XML file, it will provide all the hibernate configuration details like driver class,
driver URL, db user name, Db password..... which we required to connect with the database.

Hibernate Mapping File:
------------------------
Hibernate mapping file is an XML file, it will provide mapping between OODM[Object Oriented Data Model]
elements and RDM[Relational Data Model like 
class<------>table
id prop<----->PK column
prop<-------->column

Client Appl:
------------
Client appl will have resoponsibilities like 
1. Activate Hibernate Software
2. Create Persistence Object
3. Perform Persistence Operation with persistence objedct.

Hibernate Software:
-------------------
When HBN S/W activated by client, HBN S/W will take configuration details from configuration file and established
connection with database.
When persistence operation performed by client , HBN S/W will prepare the equivalent database dependent native SQL
query and it will execute that SQL query and generate results from DB to Java appl.
  
Hibernate Internal Service:
--------------------------
1. JDBC
2. Connection Pooling
3. Cache Mechanism
-----------
-----------


1. Hibernate Configuration File
2. Hibernate Mapping File
3. Persistence Object
4. Client Application
5. Hibernate Software

Steps To Prepare Hibernate Applicaitons:
-----------------------------------------
1. Download Hibernate from Internet and install it.
2. Create Hibernate Persistence Class
3. Create Hibernate Mapping File
4. Create Hibernate Configuration File 
5. Create Client Application and execute client appl

Note: To do all the above steps, we need the required tables in Databases.


1. Download Hibernate from Internet and install it:
---------------------------------------------------
1. Download Hibernate JAR file from internet
2. Create Java project in Eclipse IDE
3. Create seperate Hibernate library, that is , User defined library in eclipse IDE
   with all the required Hibernate JARs...

https://sourceforge.net/projects/hibernate/files/latest/download
Required JArs:
--------------
hibernate3.jar
antlr-2.7.6.jar
commons-collections-3.1.jar
dom4j-1.6.1.jar
javaassist-3.12.0.GA.jar
jta-1.1.jar
slf4j-api-1.6.1.jar
hiberante-jpa-2.0-api-1.0.1.final.jar
ojdbc6.jar

Note: If we use Eclipse IDE then keep all the above JARs either in Buildpath directly and 
      prepare a seperate user defined library with the above JARs.

Note: If we don't want to use any IDE then keep all the above JARs in
 "C:\Program Files\Java\jdk1.8.0_121\jre\lib\ext"



2. Create Hibernate Persistence Class:
---------------------------------------
It is a normal JAVA Bean class, whose objects are able to manage peristence data
inorder to perform persistence operations like inserting data, searching data, updating 
data and deleting data.

Guidlines to prepare Persistence Classes:
1. Persistence class must be a POJO[Plain Old Java Object] class, it must not extend or 
   implement any predefined library, it is a normal plain java bean class.
Note: In general, POJO classes are not extended or not implemented any predefined 
library, but, it is suggestable to implement java.io.Serializable interface.

2. Always, persistence classes must be public, non abstract and non final,because,
   a) The main intention to declare persistence class as public is to bring scope of
       the persistence class to Hibernate software inorder to create objects.
   b) The main intention to declare persistence class as non abstract is to allow to 
      create objects for persistence class.
   c) The main intetion to declare persistence classes as non final is to allow
      inheritance between persistence classes inorder to improve code reusability.

3. In persistence classes, we have to declare all properties w.r.t the database table
   columns, where persistence class properties names and database table column names need
   not be same, but, the data types must be compatible. 
  
4. In persistence classes, we must provide all properties as "private" properties.

5. In persistence classes, we msut provide a seperate set of setXXX() and getXXX()
   methods for each and every property.

6. In persistence classes, all the methods including setXXX() and getXXX() must be
   declared as "public"
Note: The main intention of declaring all properties as "private" and all methods as 
     "public" is to transfer the data through the methods inorder to improve Encapsulation 
      in persistence classes.

7. In persistence classes, it is manadatory to manage an ID property, it must represent 
   Primary key column in the respective database table.

8. In persistence classes, if we want to provide any constructor then we must provide a 
   public and 0-arg construcotor, because, while creating objects for persistence classes
   Hibernate Software will search and execute only pulbic and 0-arg construtor.

9. In persistence classes, if we want to provide our own customizaion while checking 
   whether two persistence objects are same or not then it is suggestable to override
   equals() method in persistence classes.

10. In persistence classes, it is suggestable to override hashCode() method if we want to 
    provide customization while generating persistence Objects Hashcode values.

EX:
---
package com.cts.pojo;
public class User implements Serializable{
private String uname;
private String upwd;

public void setUname(Stirng uname){
  this.uname = uname;
}
public void setUpwd(String upwd){
  this.upwd = upwd;
}
public String getUname()
  return uname;
}
public String getUpwd()
  return upwd;
}
}


3. Create Hibernate Mapping File:
-----------------------------------
--> Its main intention is to provide mapping between object oriented data model elements
and relational model elements like below.
Class --------> Table
Id prop ------> PK Column
prop ---------> Column

It is an XML document in Hibernate applications, it will provide the following
configurations in Hibernate applicaitons
1. Basis O-R mapping
2. Component Mapping
3. Inheritacne Mapping
4. Associations Mapping
5. Filters Configurations
6. Procedures and Functions Configuration
   ---------
   ---------

In Basis Hibernate applicaitons, we need Baiss O-R mapping, for this, we have to use the
following tags.

<!DOCTYPE ------>
<hibernate-mapping>
  <class name="--" table="-->
    <id name="--" column="--"/>
    <property name="--" column="--"/>
    ---------
    ---------
  </class>
</hibernate-mapping>
Note: If the POJO classes properties names and table column names are same in case 
insensitive manner then it is optional to provide column attribute in <id> tag and 
<property> tag.

Note: POJO-Class_Name.hbm.xml (Name to save hiberanate xml file)

EX:
---
Employee.hbm.xml
----------------
<!DOCTYPE ------>
<hibernate-mapping>
  <class name="com.cts.pojo.Employee" table="emp1">
    <id name="eno" column="ENO"/>
    <property name="ename" column="ENAME"/>
    <property name="esal" column="ESAL"/>
    <property name="eaddr" column="EADDR"/>
  </class>
</hibernate-mapping>

Employee.java
--------------
public class Employee{
  private int eno;
  private String ename;
  private float esal;
  private String eaddr;
  setXXX() and getXXX();
}

emp1
|ENO|ENAME|ESAL|EADDR|

Q) In single hibernate appliaction, it is possible to provide more than one Mapping file?
------------------------------------------------------------------------------------------
Ans:
-----
Yes, it is possible to provide more than one mapping file in sigle hibernate applicaiton.
Note: In general, we will prepare a seperate mapping file for each and every POJO class.

Q) Is it manadatory to provide mapping file in Hibernate applicaitons for the entities
configurations?
-----------------------------------------------------------------------------------------
Ans:
-----
Upto Hibernate3.2.4 version, it is manadatory to provide mapping files for entities
conffiguratios, but, from Hibernate3.2.5 version onwards, mapping files are optional,
alternativily we are able to use "Annotations".

POJO-Class_Name.hbm.xml (Name to save hiberanate xml file)


4. Create Hibernate Configuration File :
----------------------------------------
It is an XML document, it will provide all the Hibernate cofiguration details which are
required to interact with database.
1. Driver class configuration
2. Driver URL configuration
3. Database user configuration
4. Database password configuration
5. Dialect Class configuration
6. Mapping File configuration
7. Connection Pooling configuration
8. Cache Mechanism configuration
9. Transactions Isolation level configuration
  ---------------
  ---------------

<!DOCTYPE ----> 
<hiberante-configuration>
  <sessionfactory>
     <property name="--"> value </property>
      --------
     <mapping resource="--"/>
     -------
  </sessionfactory>
</hiberante-configuration>

EX:
---
<!DOCTYPE ----> 
<hiberante-configuration>
  <sessionfactory>
     <property name="hibernate.connection.driver_class"> oracle.jdbc.OracleDriver </property>
      <property name="hibernate.connection.url">
         jdbc:oracle:thin:@localhost:1521:xe
      </property>
      <property name"hibernate.connection.uername">system</property>
      <property name="hibernate.conncetion.password">root</property>
      <property name="hibernate.dialect">org.hibernate.dialect.OracleDialect</property>
     <mapping resource="Employee.hbm.xml"/>
     -------
  </sessionfactory>
</hiberante-configuration>

Note: hibernate.cfg.xml (use this name to save configuration xml file)

Note: We can provide more than one configuration file, when we are using more than one database in our applicaiton.

5. Create Client Application and execute client appl:
-------------------------------------------------------
The main intention of the client application is to activate Hibernate sofrware,
preaparing persistence object and performing persistence operations.

Steps:
------
1. Create Configuration Object and encapsulate Hibernate configuraiton details from
Hibernate configuration file.
2. Create SessionFactory Object
3. Create Session Object
4. Create Transaction Object
5. Perform Persistence operations by creating persistence object
6. Commit/Rollback the results.
7. Close the session and SessionFactory

1. Create Configuraiton Object:
--------------------------------
The main intention of the configuraiton object is to manage all the configuraiton details 
which are required by the Hibernate Software inorder to interact with database.

To represent configuration object, Hiberante has provided a seperate predefined class
in the form of org.hiberante.cfg.Configuration
Ex: Configuration cfg = new Configuration();
    cfg.configure();

public Configuration configure() ---> hibernate.cfg.xml file
public Configuration configure(String cfg_File) ---> MyConfig.xml
pulbic Configuration configure(File f) ---> File object
public Configuration configure(URL url) ---> Network

It is Heavy weight Object and it is Singleton object upto a particular Database and it is Threadsafe upto a particular Database.

Q) Is it possible to create More than one configuration object in a single Hibernate application?
--------------------------------------------------------------------------------------------------
Ans:
----
Yes, It is possible to provide more than one Configuration object in single Hibernate application,
but, we have to use more than one configuration file and more than one DB.

More than one Conf object <--- More than one Conf file <-- More than one DB


2. Create SessionFactory Object:
---------------------------------
The main intention of SeesionFactory is to get all the required configuration details
from Configuraiton file and it will load and register the driver, it will establish
connection between Hibernate appl and Database.......

It is a Factory for Session Object.

To represent SessionFactory object, Hibernate has provided a predefined interface in 
the form of org.hibernate.SessionFactory.

To create SessionFactory object, Configuration class has provided the following method.

public SessionFactory buildSessionFactory()
Ex: SessionFactory sf = cfg.buildSessionFactory();

SeesionFactory is Threadsafe upto a single Database.

3. Create Session Object:
---------------------------
The main intention of the Session obejct is to create an environment inorder to perform
database operations.

It will provide predefined library to perform persistence operations in Hibernate
applications.

To represent Session object, Hibernate has provided a predefined interface in the form
of "org.hibernate.Session".

To get Session object, we have to use the following method from SessionFactory.

public Session openSession()
Ex: Session session = sf.openSession();

It is not Threadsafe.

4. Create Transaction Object:
------------------------------
org.hibernate.Transaction (interface)

1. public Transaction beginTransaction()
--> It will create Transaction object and it will start transaction by default.

2. public Transaction getTransaction()
--> It will create Transaction object, by default, it is not started.
--> To start Transaction we have to use the following method.
    public Transaciton begin()
EX: Transaction tx = session.beginTransacion();
Ex: Transaciton tx = session.getTransaction();
    tx.begin()

5. Perform Persistence Operations:
-----------------------------------
1. To insert persistence Object in DB.
   a) save()
   b) persist()

2. To update a record in database.
   a) update()
   b) saveOrUpdate()

3. To delete a record from database
   a) delete(0

4. To retrieve a record from database
   a) get()
   b) load()
Note: All the above methods are defined in ord.hibernate.Session interface.

Q)What is the difference between save() method and persist() method?
---------------------------------------------------------------------
Ans:
----
Both the methods are used to insert a persistence object/ a record in database, but, if
we use save() method then Hibernate Software will insert a record in DB and return its
primary key value, but, if we use persist() method tehn it will insert a record in DB
and it will not return primary key value.

public Serializable save(Object obj)
public void persist(Object obj)


Q)What is the difference between update() method and saveOrUpdate() method?
--------------------------------------------------------------------------
Ans:
----
In Hibernate applicaitons, if we use update() operation to perform updations then 
Hibernate Software will check whether the respective record is exited or not in
Database, if the record is exited then Hibernate Software will perform updations in
the respective record. If the respective record is not exited in database then Hibernate
Software may raise an Exception.

public void update(Object obj)

In Hibernate applications, if we use saveOrUpdate() method to perform update operation
then Hibernate Software will check whether the respective record is exited or not in 
database tabel, if the record is existed then Hibernate Software will perform updations
on the respective record,if respective record is not existed then Hiberante Software
will perform save operation.

public void saveOrUpdate(Object obj)

delete(): It can be used to delete a record from database table.
public void delete(Object obj)

Q) What is the difference between get() and load() method?
-----------------------------------------------------------
Ans:
------

Note: All the above methods are used to perform single record manipulation only.

If we want to perform manipulation with multiple records like retrieving multiple
records, updating multiple records, daleting multiple records, then we have to use
1. HQL
2. Native SQL
3. Criterion API

6. Perform either commit / rollback operation in Hibernate software:
--------------------------------------------------------------------
When we perform non select operations in Hibernate applications then must perform either
commit or rollback operations

public void commit()
public void rollback()

7. Close the resources:
------------------------
At the end of Hibernate applications, it is convention to close Session and 
SessionFactory.

public void close()

session.close();
sessionFactory.close();
-------------------------------------------------------------------------------------------
0. Download Hibernate JARs from internet
1. Create Java Project in Eclipse IDE.
2. Create User defined library for Hibernate JARs and ojdbc.6jar in eclipse IDE.
3. Create Persistence Class
4. Create Mapping File
5. Create Configuratation File
6. Create Client Application and Run Cleint Application

Note: To run Hibernate applcation, we need a table in  database.

Required JArs:
--------------
hibernate3.jar
antlr-2.7.6.jar
commons-collections-3.1.jar
dom4j-1.6.1.jar
javaassist-3.12.0.GA.jar
jta-1.1.jar
slf4j-api-1.6.1.jar
hiberante-jpa-2.0-api-1.0.1.final.jar
ojdbc6.jar


Hibernate:
Example on save and persist() methods:
Employee.java
--------------
package com.cts.pojo;

public class Employee {
	private int eno;
	private String ename;
	private float esal;
	private String eaddr;
	
	public int getEno() {
		return eno;
	}
	public void setEno(int eno) {
		this.eno = eno;
	}
	public String getEname() {
		return ename;
	}
	public void setEname(String ename) {
		this.ename = ename;
	}
	public float getEsal() {
		return esal;
	}
	public void setEsal(float esal) {
		this.esal = esal;
	}
	public String getEaddr() {
		return eaddr;
	}
	public void setEaddr(String eaddr) {
		this.eaddr = eaddr;
	}
	
}

Employee.hbm.xml
-----------------
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC 
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
	<class name="com.cts.pojo.Employee" table="emp1">
		<id name="eno" column="ENO"/>
		<property name="ename" column="ENAME"/>
		<property name="esal" column="ESAL"/>
		<property name="eaddr" column="EADDR"/>
		
	</class>
</hibernate-mapping> 

hibernate.cfg.xml
-----------------
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC 
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
	<class name="com.cts.pojo.Employee" table="emp1">
		<id name="eno" column="ENO"/>
		<property name="ename" column="ENAME"/>
		<property name="esal" column="ESAL"/>
		<property name="eaddr" column="EADDR"/>
		
	</class>
</hibernate-mapping>

Test.java
---------
package com.cts.test;


import java.util.Date;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;

import com.cts.pojo.Employee;
public class Test {

	public static void main(String[] args) throws Exception {
		System.out.println(new Date(System.currentTimeMillis()));
		Configuration config = new Configuration();
		config.configure();
		SessionFactory sessionFactory = config.buildSessionFactory();
		Session session = sessionFactory.openSession();
		Transaction tx = session.beginTransaction();
		Employee emp = new Employee();
		emp.setEno(999);
		emp.setEname("HHH");
		emp.setEsal(60000);
		emp.setEaddr("Ban");
		Integer eno1 = (Integer)session.save(emp);
		//int eno = eno1.intValue();
		session.persist(emp);
		tx.commit();
		System.out.println("Employee Inserted Successfully");
		System.out.println(new Date(System.currentTimeMillis()));
//		if(eno == 444){
//			System.out.println("Employee Inserted Succesfully");
//		}else{
//			System.out.println("Employee Insertion Failure");
//		}
		session.close();
		sessionFactory.close();
	}

}



Hiberante:
Example on update() and saveOrUpdate() methods:
-------------------------------------------------
Employee.java
---------------
package com.cts.pojo;

public class Employee {
	private int eno;
	private String ename;
	private float esal;
	private String eaddr;
	public int getEno() {
		return eno;
	}
	public void setEno(int eno) {
		this.eno = eno;
	}
	public String getEname() {
		return ename;
	}
	public void setEname(String ename) {
		this.ename = ename;
	}
	public float getEsal() {
		return esal;
	}
	public void setEsal(float esal) {
		this.esal = esal;
	}
	public String getEaddr() {
		return eaddr;
	}
	public void setEaddr(String eaddr) {
		this.eaddr = eaddr;
	}
	
}

Employee.hbm.xml
-----------------
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC 
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
	<class name="com.cts.pojo.Employee" table="emp1">
		<id name="eno"/>
		<property name="ename"/>	
		<property name="esal"/>
		<property name="eaddr"/>
		</class>
</hibernate-mapping>

Configuration.cfg.xml
----------------------
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-configuration PUBLIC
	"-//Hibernate/Hibernate Configuration DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
	<session-factory>
		<property name="hibernate.connection.driver_class">oracle.jdbc.OracleDriver</property>
		<property name="hibernate.connection.url">jdbc:oracle:thin:@localhost:1521:xe</property>
		<property name="hibernate.connection.username">system</property>
		<property name="hibernate.connection.password">root</property>
		<property name="hibernate.dialect">org.hibernate.dialect.OracleDialect</property>
		<property name="hibernate.show_sql">true</property>
		<mapping resource="Employee.hbm.xml"/>
	</session-factory>
</hibernate-configuration>

Test.java
----------
package com.cts.test;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;

import com.cts.pojo.Employee;

public class Test {

	public static void main(String[] args) {
		Configuration config = null;
		SessionFactory sessionFactory = null;
		Session session = null;
		Transaction tx = null;
		
		try{
			config = new Configuration();
			config.configure();
			sessionFactory = config.buildSessionFactory();
			session = sessionFactory.openSession();
			tx = session.beginTransaction();
			tx.begin();
			Employee emp = new Employee();
			emp.setEno(124);
			emp.setEname("XXX");
			emp.setEsal(40000);
			emp.setEaddr("Chennai");
			//session.update(emp);
			session.saveOrUpdate(emp);
			tx.commit();
			System.out.println("Employee Inserted/Updated Succesfully");
			
		}catch(Exception e){
			tx.rollback();
			System.out.println("Employee Insertion/Updation Failure");
			e.printStackTrace();
		}finally{
			session.close();
			sessionFactory.close();
		}
	}

}



Hibernate
----------
Example on delete() methods:
-----------------------------
Employee.java
---------------
package com.cts.pojo;

public class Employee {
	private int eno;
	private String ename;
	private float esal;
	private String eaddr;
	public int getEno() {
		return eno;
	}
	public void setEno(int eno) {
		this.eno = eno;
	}
	public String getEname() {
		return ename;
	}
	public void setEname(String ename) {
		this.ename = ename;
	}
	public float getEsal() {
		return esal;
	}
	public void setEsal(float esal) {
		this.esal = esal;
	}
	public String getEaddr() {
		return eaddr;
	}
	public void setEaddr(String eaddr) {
		this.eaddr = eaddr;
	}
	
}

Employee.hbm.xml
-----------------
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC 
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
	<class name="com.cts.pojo.Employee" table="emp1">
		<id name="eno"/>
		<property name="ename"/>	
		<property name="esal"/>
		<property name="eaddr"/>
		</class>
</hibernate-mapping>

Configuration.cfg.xml
----------------------
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-configuration PUBLIC
	"-//Hibernate/Hibernate Configuration DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
	<session-factory>
		<property name="hibernate.connection.driver_class">oracle.jdbc.OracleDriver</property>
		<property name="hibernate.connection.url">jdbc:oracle:thin:@localhost:1521:xe</property>
		<property name="hibernate.connection.username">system</property>
		<property name="hibernate.connection.password">root</property>
		<property name="hibernate.dialect">org.hibernate.dialect.OracleDialect</property>
		<property name="hibernate.show_sql">true</property>
		<mapping resource="Employee.hbm.xml"/>
	</session-factory>
</hibernate-configuration>

Test.java
----------
package com.cts.test;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;

import com.cts.pojo.Employee;

public class Test {

	public static void main(String[] args) {
		Configuration config = null;
		SessionFactory sessionFactory = null;
		Session session = null;
		Transaction tx = null;
		
		try{
			config = new Configuration();
			config.configure();
			sessionFactory = config.buildSessionFactory();
			session = sessionFactory.openSession();
			tx = session.beginTransaction();
			tx.begin();
			Employee emp = new Employee();
			emp.setEno(124);
			session.delete(emp);
			tx.commit();
			System.out.println("Employee deleted Succesfully");
			
		}catch(Exception e){
			//tx.rollback();
			System.out.println("Employee deletion Failure");
			e.printStackTrace();
		}finally{
			session.close();
			sessionFactory.close();
		}
	}

}
  


Q)What is the difference between get() method and load() method from Session in
Hibernate?
--------------------------------------------------------------------------------------------------------------
Ans:
-------
Both the methods are used to retrieve a record from database in the form of Entity / POJO
object.

public Object get(Class class, Serializable PK_Val)throws HibernateException
public Object get(String entity_Class, Serializable PK_Val)throws HibernateException


public Object load(Class class, Serializable PK_Val)throws HibernateException
public Object load(String entity_Class, Serializable PK_Val)throws HibernateException

To get record form database, if we use get() method then Hibernate Software will perform
the following actions.
1. Hibernate Software will interact with database and checks whether the
    respective record is exited or not on the basis of the provided primary key value.
2. If the record is existed .then Hibernate Software will return in the form
    of POJO object to Hibernate Client Application.
3. If the record is not existed then Hibernate Software will return null value without
    raising any Exception.

To get record from Database, if we use load() method then Hibernate Software will
perform the following actions.
1. Hibernate Software will create a Proxy Object[Dupicate/Fake Object] for the
    respective entity class with the provided primary key value without interacting
    with the database.
2. When we access non-primary key value from the proxy object then Hibernate Software
    will interact with database and it will check whether record is exited or not on the basis of 
    the provided primary key value.
3. If the record is exited then Hibernate Software will return that record data in the form of
    POJO class object.
4. If the record is not exited then Hibernate Software will raise an Exception like
    "org.hibernate.ObjectNotFoundExceptin".

Note: get() method is performing early/eagre loading and load() method is performing
          lazy loading.
Hibernate
----------
Example on get() and load() methods:
-----------------------------
Employee.java
---------------
package com.cts.pojo;

public class Employee {
	private int eno;
	private String ename;
	private float esal;
	private String eaddr;
	public int getEno() {
		return eno;
	}
	public void setEno(int eno) {
		this.eno = eno;
	}
	public String getEname() {
		return ename;
	}
	public void setEname(String ename) {
		this.ename = ename;
	}
	public float getEsal() {
		return esal;
	}
	public void setEsal(float esal) {
		this.esal = esal;
	}
	public String getEaddr() {
		return eaddr;
	}
	public void setEaddr(String eaddr) {
		this.eaddr = eaddr;
	}
	
}

Employee.hbm.xml
-----------------
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC 
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
	<class name="com.cts.pojo.Employee" table="emp1">
		<id name="eno"/>
		<property name="ename"/>	
		<property name="esal"/>
		<property name="eaddr"/>
		</class>
</hibernate-mapping>

Configuration.cfg.xml
----------------------
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-configuration PUBLIC
	"-//Hibernate/Hibernate Configuration DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
	<session-factory>
		<property name="hibernate.connection.driver_class">oracle.jdbc.OracleDriver</property>
		<property name="hibernate.connection.url">jdbc:oracle:thin:@localhost:1521:xe</property>
		<property name="hibernate.connection.username">system</property>
		<property name="hibernate.connection.password">root</property>
		<property name="hibernate.dialect">org.hibernate.dialect.OracleDialect</property>
		<property name="hibernate.show_sql">true</property>
		<mapping resource="com/cts/resources/Employee.hbm.xml"/>
	</session-factory>
</hibernate-configuration>

Test.java
----------
package com.cts.test;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;

import com.cts.pojo.Employee;

public class Test {

	public static void main(String[] args) {
		Configuration config = null;
		SessionFactory sessionFactory = null;
		Session session = null;
		Transaction tx = null;
		try {
			config = new Configuration();
			config.configure("/com/cts/resources/myconfig.xml");
			sessionFactory = config.buildSessionFactory();
			session = sessionFactory.openSession();
//			Employee emp = (Employee) session.get(Employee.class, 111);
//			if(emp == null){
//				System.out.println("Employee does not exited");
//			}else{
//				System.out.println("Employee Details");
//				System.out.println("----------------------");
//				System.out.println("Employee Number   :"+emp.getEno());
//				System.out.println("Employee Name     :"+emp.getEname());
//				System.out.println("Employee Salary   :"+emp.getEsal());
//				System.out.println("Employee Address  :"+emp.getEaddr());
//			}
			System.out.println("Before Calling load()");
			Employee emp = (Employee) session.load(Employee.class, 111);
			System.out.println(emp.getEno());
			System.out.println("After Calling load()");
			System.out.println(emp.getEname());
//			if(emp == null){
//				System.out.println("Employee does not exited");
//			}else{
//				System.out.println("Employee Details");
//				System.out.println("----------------------");
//				System.out.println("Employee Number   :"+emp.getEno());
//				System.out.println("Employee Name     :"+emp.getEname());
//				System.out.println("Employee Salary   :"+emp.getEsal());
//				System.out.println("Employee Address  :"+emp.getEaddr());
//			}
	
			
		} catch (Exception e) {
			//tx.rollback();
			System.out.println();
			e.printStackTrace();
		}finally {
			session.close();
			sessionFactory.close();
		}
	}

}

Hiberante: 
-----------
Example on AWT-Hiberante Intergration:

EmployeeSearchFrame.java
-------------------------
package com.cts.ui;

import java.awt.Button;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.Label;
import java.awt.TextField;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

import com.cts.factory.EmployeeServiceFactory;
import com.cts.pojo.Employee;
import com.cts.service.EmployeeService;
import com.cts.service.EmployeeServiceImpl;

public class EmployeeSerchFrame extends Frame implements ActionListener {
	Label l;
	TextField tf;
	Button b;
	Employee emp;
	
    public EmployeeSerchFrame() {
		this.setVisible(true);
		this.setSize(500,500);
		this.setTitle("Employee Serch Frame");
		this.setLayout(new FlowLayout());
		this.setBackground(Color.green);
		this.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent we){
				System.exit(0);
			}
		});
		
		l = new Label("Employee Number");
		tf = new TextField(20);
		b = new Button("Search");
		b.addActionListener(this);
		
		Font font = new Font("consolas", Font.BOLD, 20);
		l.setFont(font);
		tf.setFont(font);
		b.setFont(font);
		
		this.add(l);
		this.add(tf);
		this.add(b);
		
		
	}
	@Override
	public void actionPerformed(ActionEvent arg0) {
		try {
			int eno = Integer.parseInt(tf.getText());
			EmployeeService empService = EmployeeServiceFactory.getEmployeeService();
			emp = empService.search(eno);
			repaint();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	@Override
	public void paint(Graphics g) {
		Font font = new Font("consolas", Font.BOLD, 25);
		g.setFont(font);
		
		if(emp == null){
			g.drawString("Employee Not Exited", 50, 250);
		}else{
			g.drawString("Employee Number  :"+ emp.getEno(), 50, 200);
			g.drawString("Employee Name    :"+ emp.getEname(), 50, 250);
			g.drawString("Employee Salary  :"+ emp.getEsal(), 50, 300);
			g.drawString("Employee Address :"+ emp.getEaddr(), 50, 350);
		}
	}

}


EmployeeService.java
---------------------
package com.cts.service;

import com.cts.pojo.Employee;

public interface EmployeeService {
	public Employee search(int eno);
}



EmployeeServiceImpl.java
-------------------------
package com.cts.service;

import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;
import org.hibernate.classic.Session;

import com.cts.pojo.Employee;
import com.cts.util.HibernateUtil;

public class EmployeeServiceImpl implements EmployeeService {
	Employee emp;
  
	public Employee search(int eno) {
		try {
			SessionFactory sessionFactory = HibernateUtil.getSessionFactory();
			Session session = sessionFactory.openSession();
			emp = (Employee) session.get(Employee.class,eno);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return emp;
	}
}

EmployeeServiceFactory.java
-----------------------------
package com.cts.factory;

import com.cts.service.EmployeeService;
import com.cts.service.EmployeeServiceImpl;

public class EmployeeServiceFactory {
	private static EmployeeService empService;
	static{
		empService = new EmployeeServiceImpl();
	}
	public static EmployeeService getEmployeeService() {
		return empService;
	}
}


Employee.java
---------------
package com.cts.pojo;

public class Employee {
	private int eno;
	private String ename;
	private float esal;
	private String eaddr;
	public int getEno() {
		return eno;
	}
	public void setEno(int eno) {
		this.eno = eno;
	}
	public String getEname() {
		return ename;
	}
	public void setEname(String ename) {
		this.ename = ename;
	}
	public float getEsal() {
		return esal;
	}
	public void setEsal(float esal) {
		this.esal = esal;
	}
	public String getEaddr() {
		return eaddr;
	}
	public void setEaddr(String eaddr) {
		this.eaddr = eaddr;
	}
}

Employee.hbm.xml
-------------------
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC 
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
	<class name="com.cts.pojo.Employee" table="emp1">
		<id name="eno"/>
		<property name="ename"/>	
		<property name="esal"/>
		<property name="eaddr"/>
		</class>
</hibernate-mapping>

hiberante.cfg.xml
-------------------
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-configuration PUBLIC
	"-//Hibernate/Hibernate Configuration DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
	<session-factory>
		<property name="hibernate.connection.driver_class">oracle.jdbc.OracleDriver</property>
		<property name="hibernate.connection.url">jdbc:oracle:thin:@localhost:1521:xe</property>
		<property name="hibernate.connection.username">system</property>
		<property name="hibernate.connection.password">root</property>
		<property name="hibernate.dialect">org.hibernate.dialect.OracleDialect</property>
		<property name="hibernate.show_sql">true</property>
		<mapping resource="com/cts/resources/Employee.hbm.xml"/>
	</session-factory>
</hibernate-configuration>

hibernateUtil.java
-------------------
package com.cts.util;

import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

public class HibernateUtil {
	private static SessionFactory sessionFactory;
	static{
		try{
			Configuration config = new Configuration();
			config.configure("/com/cts/resources/hibernate.cfg.xml");
			sessionFactory = config.buildSessionFactory();
		}catch(Exception e){
			e.printStackTrace();
		}
	}
	public static SessionFactory getSessionFactory(){
		return sessionFactory;
	}
}


Test.java
----------
package com.cts.test;

import com.cts.ui.EmployeeSerchFrame;

public class Test {

	public static void main(String[] args) {
		EmployeeSerchFrame frame = new EmployeeSerchFrame();
	}

}



