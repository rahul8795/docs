Spring:
--------
1. Core Module
2. JDBC/DAO Module
   1. Load and Register Driver
      Class.forName("oracle.jdbc.OracleDriver");
   2. Establish Connection between Java application and database
      Connection con = DriverManager.getConnection("
      jdbc:oracle:thin:@localhost:1521:xe","system","root");
   3. Create either Statement or preparedStatement or CallableStatement :
      Statement st = con.createStatement();
   4. Write and execute SQL queries:
      ResultSet re = st.executeQuery("select *from emp1");
      int rowCount = st.executeUpdate("insert into emp1 values(-----)");
      boolean b = st.execute("update emp1 set ESAL = ESAL + 5000 where ESAL < 10000");
   5. rs.close();
      st.close();
      con.close();


jdbcTemplate.execute("select *from emp1");

3. Spring ORM Module:
-------------------------
1. Create Configuration Object
   Configuration cfg = new Configuration()
   cfg.configure();

2. Create SessionFactory Object
   SessionFactory sf = cfg.buildSessionFactory();

3. Create Session object:
   Session s = sf.openSession();

4. Create Transactions Object.
   Transaction tx = s.beginTransaction();

5. Perform Database Opeartions
   int k_Val = s.save(emp);

6. tx.commit();

7. Close the resources:
   s.close();
   sf.close();

HibernateTemplate

hibernateTemplate.save(emp);


Spring AOP:
-------------


Spring Transaction:
--------------------

Spring Web Module:
--------------------
Web and Web MVC


Spring Security:
----------------
Spring-1:
---------
1. Core Module
2. AOP
3. JDBC/DAO
4. ORM
5. Transaction
6. Web and Web MVC
7. Security


1. MAVEN
2. LOG4J
3. JUNIT
Spring-2:
--------------
1. Spring Boot
2. Spring JPA
3. Spring Data-JPA
4. Spirng Cloud
5. Spring Micro Services
6. Spring Social
7. Spring Batch
------
--------

Eclipse, STS
Oracle, MySQL
Tomcat, Weblogic, JBOSS or Wildfly, Glassfish
--------------------------------------------------
1. Introduction:
-----------------
Enterprise:It is a Business Organization, it is a group of organization running under single label.

Enterprise Application: It is a Software Application designed for a enterprise, it will
simplify the internal business processing.


1. User Interface Layer / Presentation Layer 
   1. Starting Point to access our application
   2. It will improve look and feel to the enterprise application.
   3. It will take data from users inorder to submit to enterprise application.
   4. To perform Client Side Data Validations with JavaScript functions.
   5. To sent different types of requests from client to Server.
   6. Presentation Logic --> AWT, SWING, JAVS FX, HTML, JSP, .....Struts, JSF,.....

2. Business Processing Layer
   1. It is Heart of the Enterprise Applications,
      It can be used to define and execute all Business
      rules and regulations which clients exactly required.
   2. To prepare this layer we have to use a separete logic 
      called as business logic.
   3. To prepare Business Logic, we have to use a set of 
      technology Java Beans, Servlets, EJBs,....

3. Data Storage and Access Layer / Persistence Layer
   1. It is last layer in Enterprise Application develoment.
   2. Its main intention is to interact with database and to 
      perform operations as per the Business Rules and regualtions.
   3. To prepare this layer, we will use a separate logic 
      called as Persistence logic.
   4. JDBC, JPA, Tooplink,...Hibernate, EJBs-Entity Beans,.....

System Architecture:
---------------------
1. 1-Tier Arch
2. 2-Tier Arch
3. 3-Tier Arch
   ----
   ----
   n-Tier Arch

1. 1-Tier Arch:
---------------
    0. we will provide all the enterprise application layer in a single 
       machine.
    1. It is highly recomended for Standalone Application.
    2. All Three layers must be managed by single
       Machine, so single Machine resources may not
       be sufficient to execute enterprise application.
    3. It will reduce applicaiton performance.
    4. It is providing only Single User environment.
    5. It is not providing Database Sharability and Components Sharability.
    6. It is providing tightly coupled architecture.

2-Tier Arch:
------------
--> In 2-Tier arch, we will provide the complete enterprise application in two macnines.
--> In Tier-1 Machine we will use User Interface Layer and Business Processing Layer,
    in Tier-2 Machine we will use Data Storage and Access Layer.
-->  2-Tier Arch is able to provide loosly coupled design when comaored with 1-Tier Arch.
--> 2-Tier Arch is recomended for Enterprise Applicaitons and it is conventional Arch for 
    Enterprise Applicaitons.
--> 2-Tier Arch is able to improve Database Sharability.
--> Still 2-Tier Arch is not providing clearcut seperation between presentation layer 
    and Data Storage and Access Layer.
--> It is providing database sharability but it is not providing component sharability.
--> It is not suitable for Standalone Applications.
--> When compared with 1-Tier Arch, 2-Tier Arch will improve applications performance, 
    but, maintanence cost will be increased.

3-Tier Arch:
-------------


Types of Enterprise Applications:
-----------------------------------




Q) What is the difference between Web Applications and Distributed Applications?
----------------------------------------------------------------------------------------------------------------------------
Ans:
---------
1. Web Application is a Client-Server application, where in web applications the
complete application logic will be distributed at Server Machine onle.

Distributed Application is a Client-Server Application, where in Distributed 
Applications the complete application logic will be distributed over both Client Machine
and Server Machine.

2. In case of Web Applications, Client is fixed, that is, Browser.

   In case of Distributed Applications, Client is not fixed, it may be a core java program
with main() method, A GUI application with actionPerformed() method, a servlet, a JSP page,
Frameworks applications like Struts, JSF,.........

3. If we want to prepare web application we have to use a seprate set of tech called as 
Web Tech.
Ex. CGI, Servlets, JSPs, JSTL, EL, .....
If we want to prepare Distribted Application, we need a set of tech called as 
Distributed Tech.
Ex. Socket Programming, RMI, CORBA, Web Services,......

4.The main intention of Web Applications is to generate dynamic response from server.
  
  The main intention of Distributed Applications is to established communication between
Local machine and Remote Machine and to generate remote Services from Remote Machine.

5. Web Applications are executed by both Web Servers and Applications Servers.
    Distributed Applications are executed by only Application Servers.

6. Web Application is the collection of Web Components like Serlets, JSPs, .... which
   are executed by the Web Containers like Servlet Container and JSP Container ........

  Distributed Applications is the collection of EJB components, which are executed by EJB Container.


To prepare Web Applications, SUN Microsystems has given two design Models.
1. Model-I Arch [MVC1]
2. Model-II Arch [MVC2]


1. Model-I Arch:
-----------------------------
--> It is also called JSP Front Arch or Page Centric Arch


2. Model-II Arch
------------------------------
--> It is pure MVC implementation.
--> It is also called Servlet Front Arch or Servlet Centric Arch
--> Some framework like Struts, JSF, XWORKS2....... are designed on the basic of Model-II Web
application arch only,intern, Structs and JSF are MVC based Frameworks.


MVC Arch ind its Rules and Regulations:
---------------------------------------------------------------
--> MVC is a design pattern, it will provide standard tamplate to prepare web
applications.
--> MVC is a design pattern, it will define standard flow of execution for the web
applications.

1. In MVC based applications, controller must be Servlet, a set of JSP pages must be view part.
2. In MVC based web applications, only one Controller must be provided.
3. In MVC based web applications, every request must be provided to Controller only and
    every response must be generated by view part.
    Note: We must not send any request to View part and we must not generate any response
             from controller.
4. In MVC based web applications, Controller and view part are not responsible to interact with
    with databases, they may interact with database through Model component only.
5. In MVC based applications, Controller is responsible to set data to the Model
    Component and View is responsible to get Data from model component.
6. In MVC based web applications, we can write any no of JSP pages as View part, but, we
    must provide all these JSP pages as Java Code Less.
7. In MVC web applications, we can provide any no of JSP pages as View part, where 
    we must not provide Page-To-Page communication, where we must provide
    page-controller-page communication.


Q) To design web applications we have the tech like Servlets and JSPs, To run web
     applications we have Servers like Tomcat, weblogic,....,to simplify web application
     development we have already some IDEs like Eclipse, MyEclipse, Netbeans,.... to preapare
     web applications with standardization we have web application models like Model-I arch
     and Model-II arch,.....,still;, what is the requirement to usr Frameworks?
Ans:
---------
Common : Controller and generic services ----> takes 70% of the actual appl implmentation. 
Variable : JSP pages and Model ------> takes only 30% of the actual implementatiaon.


If any product provide 70% common implementation as predefined then developers work is
simplified, where Developers may provide only 30% of the remaining implementation. Here 
the third parties provided products which are providing 70% common implementation
called as "Framework".



Frameworks:
-------------

--> Framework is a Pre-Fabricated software components that programmer can reuse, share
and customize inorder to simplify Application development.

--> Framework is a semi implemented application, it will provide very good environment
to prepare enterprise applications as per developers convenience.

--> Framework is a collections of tools and APIs, it will provide very good 
envoronment to prepare enterprise applications in simplified manner.

Adv:
-----
--> Frameworks will provide standard template to design applications.
--> Frameworks will providing Standard flow of execution between components.
--> Frameworks are allowinf parallel development.
--> Frameworks are able to reduce Development time.
--> Frameworks are able to reduce development cost.
--> Frameworks are able to improve Productivity.

Types of Frameworks:
--------------------
1. Web Frameworks
2. Application Frameworks

Q) What is the difference between Web frameworks and Application frameworks?
-----------------------------------------------------------------------------
Ans:
----
Web frameworks will provide very good env to prepare and execute web applications only.
Ex. Struts, JSF, Xworks2

Application Frameworks are able to provide very good env to prepare and execute any type
of JAVA, J2EE applications like Standalone Appl, Web Appl, Distributed Appl, Database Related Appls......
EX: Spring Frameworks. 

Q) What are the differences between Struts, JSF, and Spring Framework?
-----------------------------------------------------------------------
Ans:
-----
1. Struts and JSF are web frameworks, which are used to prepare only web applications.

Spring frameworks is an applicaiton frameworksm, it will provide very good env to prepare
the applications like standalone appl, web appl, distributed appl,.....

2. Struts framework is able to provide focus on only controller layer.
   JSF framework is able to provide focus on view layer.
   Spring framework is able to focus on all the layers of enterprise appl.

3. Struts and JSF are designed mainly on MVC and its associated design patterns.
   Spring Frame's web MVC module is only designed on the top of MVC design pattern.

4. Struts and JSF are providing the generic services like I18N(Interalization), EH(Exception handling), Validations,.. but
   Struts and JSF are not providing support for middleware services like JAAS,
   JNDI, JTA, Java Mail,.....
   
   Spring framework is able to provide support for the generic Services like I19N, EH, data
   validations,... and the middleware services like JAAS, JNDI
   ,JTA, JAVA Mail,.....

5. Struts and JSF are not modularized frameworks, to prepare any simple application even
   we have to load the complete framework.

   Spring framework is modularized framework, to prepare any simple application it is not frquired to load the complete spring 
   framework, it is sufficient to load the required modules.

6. Struts and JSF are more API dependentm they not following POJO/POJI kind of
   implementations.
  
   Spring framework is less API dependent, it follows POJO/POJI kind of implementations.

7. It is difficult to perform debugging and testing over struts and JSF applicaton.
   
   It is very simple to perform debugging and testing over Spring Applicaiton.

8. Struts and JSF are heavyweight frameworks.
   Spring framework is light weight.

Struts and JSF:
---------------
public ActionForward execute(ActonsMapping, ActionForm, HttpServletRequest request,
HttpServletResponse response)throws Exception{
--------
}
Spring:
--------
public String doLogin(){
----
}

9. Struts and JSF are not providing inbuilt support for integrating the explicit
applications like EJB applocaitons, Hibernate Appl, Ajax Appl, JDBC Appl,...........

Spring framework has provided very good inbuilt support to integrate other tech
applications like EJBs, JDBC, Hibernate, Struts Appl, JSF appl,.........

10. To prepare view part, Struts and JSF are allowing the fundamental view tech like
Html, JSP.......

Spring framework is allowing the most advanced view tech Velocity, Freemarker,...
to prepare View part.

11. Struts and JSF are not having aspect orientation.
  
 Spring Framework is having aspet orientation support along with object
   orientation.

12. Struts and JSF are not having Testing Support[Developers Level Testing].

Spring Framework is providing testing support by having testing module.


Spring History
----------------
1. Home: Interface1
2. Author: Mr. Rod Johnson
3. Objective: To simplify and accelerate appl development.
4. Type: Open Source Framework
5. Type of Framework: Application Framework
6. Initial version: Spring1.0[Oct, 2004].
7. User Versions: Spring3.x, 4.x
8. Latest version: Spring5.x 
9. Website: http://spring.io
10. Designed on: JAVA, J2EE
11. Compatibility/Portability: Supported by all IDEs and Servers.
12. Tools: STS[Spring Tool Suit]

Spring Modules:
----------------
Spring1.x
-----------
1. Spring Core
2. Spring AOP
3. Spring DAO
4. Spring ORM
5. Spring Context
6. Spring Web
7. Spring Web MVC

Spring2.x
----------
1. Spring Core
2. Spring AOP
3. Spring DAO
4. Spring ORM
5. Spring JEE
6. Spring Web

Spring3.x
----------
1. Core Container
   Beans
   Core
   Context
   Expression language
2. AOP
3. Aspects
4. Instrumentation
5. Data Access and Integration
   Transactions
   JDBC
   OXM
   ORM
   JMS
6. Web
   Web
   Portlet
   Servlet
   Struts
7. Test


Spring4.x
-----------
1. Core Container
   Beans
   Core
   Context
   Spring Expression language
2. AOP
3. Aspects
4. Instrumentation
5. Messaging
6. Data Access and Integration
   Transactions
   JDBC
   OXM
   ORM
   JMS
7. Web
   Web
   Portlet
   Servlet
   WebSocket
8. Test

Spring5.x
-----------
1. Core Container
   Beans
   Core
   Context
   Spring Expression language
2. AOP
3. Aspects
4. Instrumentation
5. Messaging
6. Data Access and Integration
   Transactions
   JDBC
   OXM
   ORM
   JMS
7. Web
   Web
   Portlet
   Servlet
   WebSocket


Steps to preapare First Spring Application[Core Module]
--------------------------------------------------------
1. Download Spring Framework[Jars] from Internet.
2. Prepare Java Project in Eclipse IDE.
3. Preapre Spring Library with the required JAR files.
4. Prepare Bean class.
5. Prepare Spring Configuration file with Bean congfiguration
6. Preapare Test Application.

1. Download Spring Framework[Jars] from Internet.
------------------------------------------------------
https://repo.spring.io/release/org/springframework/spring/

1. commons-logging-1.2.jar
2. spring-beans-4.3.9.RELEASE.jar
3. spring-context-4.3.9.RELEASE.jar
4. spring-context-support-4.3.9.RELEASE.jar
5. spring-core-4.3.9.RELEASE.jar
6. spring-expression.4.3.9.RELEASE.jar


2. Prepare Java Project in Eclipse IDE.


3. Preapre Spring Library with the required JAR files.



4. Prepare Bean class:
-------------------------
--> Bean is a reusable component, it is a normal Java class having properites and the
respective setXXX() and getXXX() methods
--> Spring Frmaework isi using POJO[Plain Old Java Object] classes, it will not extend
or implement any predefined library except java.io.Serialiable marker interface.
 
    UseBean --> JSP
    ActionForm --> Struts
    BackingBean --> JSF
    POJO ----------> Hiberanate
    POJO ----------> Spring
--> In Spring Framework, POJO class must be a Java bean class, it must be declared as
public, non abstract and non final
    a)The main intention of declaring Bean as public is to make available to Spring
      framework inorder to create onjects.
    b)In spring framework applications, Spring Framework must create objects for the
      Bean class, it must be non abstract.
    In spring framework applications, if we want to extend one bean class to another
    class as per the requirement and as per improving code reusability we must
    declare bean class non final.

--> In Bean class, we must declare properties as per the requirement and we must provide
    a separate set of setXXX() and getXXX() method.
--> In Bean Class, we must declare all properties as private properties, we must declare
    all as public mehtods inorder to improve "Encapsulation".
--> In Bean class, if we want to provide constructor then we have to provide
    constructor, but, it must be public and 0-arg constructor, because, while
    instantiating Bean class, spring framework will search and excute 0-arg
    constructor and public construtor.
--> If we want to provide our own comparision between Bean objects then we have to
    override equals() method.
--> If we want to generate hashcode values of the Bean objects in our own view then we
    have to override hashcode() method.
EX:
----
public class User implements Serializable{
  private String uname;
  private String upwd;
   
  setXXX();
  getXXX();
}


5. Prepare Spring Configuration file with Bean congfiguration
---------------------------------------------------------------
--> It is an XML file, it will include all beans cinfiguration details like name of the 
Bean class, identity of the Bean Class, properties and their values of the Bean class,..
--> The main intention of Baen configuration in Spring configuration file is to crate
Bean object by Spring Framework.
--> Spring Framework is able to allow any name to the configuration file, but, the 
suggestible name is "applicationContext.xml".

or spring.xml, beans.xml, spring-beans.xml

<beans ---XSD-->
  ----
    <bean id="--" class="--"/>
  ----
</beans>

id: it will take a variable name as an identity to the generated Bean Object.
class: It will take fully qualified name of the respective Bean class.

<beans ---XSD--->
  <bean id="helloBean" class="com.cts.beans.Hellobean"/>
</beans>


6. Preapare Test Application.
-------------------------------
1. The main intention of Test application is to activate Containers from Spring 
Framework and allows to create Bean objects by getting beans details from Spring 
configuration file and to use Bean objects in our application as per the requirement.

2. There are two types of containers in Spring Frmaework,
   1. BeanFactory
   2. ApplicationContext

ApplicaitonContext is an interface provided by Spring Framework and one its
implementation is "ClassPathXmlApplicationContext".

3. To create ApplicationContext container we have to use the following code.
   ApplicationContext context = new ClassPathXmlApplocationContext("/com/cts/
   resources/applicationContext.xml");
   a)ApplicationContext container will take naem and location of the spring conf file.
   b)ApplicationContext container will load spring configuration file to memoru.
   c)ApplicationContext container will parse spring configuration file.
   d)ApplicationContext container will read beans configuration details from Spring
     Configuration file.
   e)ApplicationContext container will create bean class objects and maintain bean
     class objects.

4. Get Bean object from ApplicationContext container on the basis of id.
   public Object getBean(String id); 
   HelloBean hb = (HelloBean)context.getBean("helloBean"); 


In C:
printf("User Name :");
scanf("---");

In Java:
--------
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
System.out.println("User Name : ");
String data = br.readLine();


Three ways to provide value to bean class :
---------------------------------------------
1. As parameters to business methid in Bean class.
2. By providing setXXX() and getXXX() methods in Bean class and by excuting setXXX()
   method.
3. By declairng data in Spring configuration file as property in bena configuration.


Spring:
---------
Example on Beans and its configuration in Spring configuration file:

HelloBean.java:
----------------
package com.cts.beans;

public class HelloBean {
	private String name;
	public void setName(String name){
		this.name = name;
	}
	public String getName(){
		return name;
	}
	public String sayHello(){
		return "Hello " + name + " !";
	}
}

applicationContext.xml:
------------------------
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
        <bean id="helloBean" class="com.cts.beans.HelloBean">
        <property name="name" value="Durga"/>
        </bean> 
</beans>

Test.java:
------------
package com.cts.test;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.cts.beans.HelloBean;

public class Test {

	public static void main(String[] args) {
		ApplicationContext context = new ClassPathXmlApplicationContext("/com/cts/resources/applicationContext.xml");
		HelloBean hello = (HelloBean) context.getBean("helloBean");
		//hello.setName("Rahul");
		System.out.println(hello.sayHello());
	}

}

IOC Containers:
---------------
The main intention of IOC containers is to create Bean objects and to supply bean 
objects to Spring Application.

There are two types of IOC containers:
1. BeanFactory
2. ApplicaitoContext 

1. BeanFactory:
-----------------
--> It is basis / fundamental / outdated container to create Bean objects in Spring Applications.
--> It is providing the functionalities like creating bean objects and supplying bean
objects to the Spring Applicaitons, it is not providing the advanced features like I18N, 
Event Notificaiton model,.... in Spring Applications.
--> BeanFactory is deprecated from Spring3.x version.
--> BeanFactory is able to represent by Spring framework in the form of an interface
    "org.springframework.beans.factory.BeanFactory".
-->Spring framework has provided an implementaiton class to BeanFactory interface in the form of 
   "org.springframework.beans.factory.xml.XmlBeanFactory".

1. Create Resource object
2. Create BeanFactory object
3. Get Bean Object from Beanfactory and Access Business Methods.

Resource:
----------
To represent beans configuration details which we provided in spring configuration file
then we have to use Resource object...

To represent Resource objects, Spring framework has provided a predefined interface in 
the form of "org.springframework.core.io.Resource".

Spring Framework has provided predefined implementation classes for Resource interface.

1. org.springframework.core.io.ByteArrayResource
2. org.springframework.core.io.FileSystemResource
3. org.springframework.core.io.ClassPathResource
4. org.springframework.core.io.InputStreamResource
5. org.springframework.core.io.UrlResource
6. org.springframework.web.context.support.ServletContextResource
7. org.springframework.web.portlet.context.PortletContextResource
 

Resource resource = new ClassPathResource("spirng-config.xml");

2. Create BeanFactory object:
------------------------------
BeanFactory factory = new XmlBeanFactory(reosurce)

3. Get Bean Object and Access Business Method.

public void getBean(String id)

HelloBean hello = (HelloBean) factory.getBean("helloBean");

Spring[Core]:
-------------
Example on BeanFactory IOC Container.

Employee.java
--------------
package com.cts.beans;

public class Employee {
	private int eno;
	private String name;
	private float esal;
	private String eaddr;
	public int getEno() {
		return eno;
	}
	public void setEno(int eno) {
		this.eno = eno;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public float getEsal() {
		return esal;
	}
	public void setEsal(float esal) {
		this.esal = esal;
	}
	public String getEaddr() {
		return eaddr;
	}
	public void setEaddr(String eaddr) {
		this.eaddr = eaddr;
	}
	
	
	public void getEmpDetails() {
		System.out.println("Employee Details");
		System.out.println("----------------------");
		System.out.println("Employee Number  :"+eno);
		System.out.println("Employee Name    :"+name);
		System.out.println("Employee Salary  :"+esal);
		System.out.println("Employee Address :"+eaddr);
		
	}
}

applicationContext.xml:
--------------------------
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
        <bean id="empBean" class="com.cts.beans.Employee">
        	<property name="eno" value="111"></property>
        	<property name="name" value="Rahul Dubey"></property>
        	<property name="esal" value="50000"></property>
        	<property name="eaddr" value="Pune"></property>
        </bean>
</beans>

Test.java:
-----------
package com.cts.test;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;

import com.cts.beans.Employee;

public class Test {

	public static void main(String[] args) {
		 Resource resource = new ClassPathResource("/com/cts/resources/applicationContext.xml");
		 BeanFactory factory = new XmlBeanFactory(resource);
		  // BeanFactory factory = new XmlBeanFactiry(new ClassPathResource("applicationContext.xml"));
		 Employee emp = (Employee) factory.getBean("empBean");
		 emp.getEmpDetails();
	}

}

Note: BeanFactory performance is slow that's why alternative is AppliocationContext. BeanFactory is best for memory utilization.
      BeanFactory follow lazy and AppliocationContext follow eager loading.

2. ApplicaitoContext: 
----------------------
--> ApplicaitonContex is an IOC Container in spring framework, it will create Bean
onjects and it will suply Bean objects to Spring Applicaitons.

--> AppicaitonContext is child to BeanFactory, it able to perform all the 
functionalities what BeanFactory is performing and it will provide the advanced features
like I18N, Event Notificaiton Model,.....

--> In Spring Framework, ApplicaitonContext is represented in the form of a predefined 
interface "org.springframework.context.ApplicationContext", it is a child interface to 
"BeanFactory" interface.

--> Spring Framework has provided the following implementation classes for 
ApplcaitionContext interface.

1. ClassPathXmlApplicaitonContext  
2. FileSystemXmlApplicationContext
3. WebXmlApplicationContext


ApplicationContext context = new ClassPathXmlApplicationCOntext
("aaplicaitonContext.xml");

1. Prepare Bean classes as per the requirement.
2. Preapre Spring Configuration File and provide beans configurations.
3. Prepare Test Applcation, where we must use ApplicaitonContext container to manage
   beans.

Spring[Core Module]
--------------------
Student.java
------------
package com.cts.beans;

public class Student {
	private String sid;
	private String sname;
	private String saddr;
	public String getSid() {
		return sid;
	}
	public void setSid(String sid) {
		this.sid = sid;
	}
	public String getSname() {
		return sname;
	}
	public void setSname(String sname) {
		this.sname = sname;
	}
	public String getSaddr() {
		return saddr;
	}
	public void setSaddr(String saddr) {
		this.saddr = saddr;
	}
	
	public void getStudentDetails() {
		System.out.println("Student Details");
		System.out.println("-----------------");
		System.out.println("Student Id    :"+sid);
		System.out.println("Student Name  :"+sname);
		System.out.println("Student Address :"+saddr);
		
	}
	
}

applicationContext.xml
------------------------
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
        <bean id="stdBean" class="com.cts.beans.Student">
        	<property name="sid" value="S-111"></property>
        	<property name="sname" value="Durga"></property>
        	<property name="saddr" value="Gujrat"></property>
        	
        </bean>
</beans>

Test.java
----------
package com.cts.test;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.cts.beans.Student;

public class Test {

	public static void main(String[] args) {
		ApplicationContext context = new ClassPathXmlApplicationContext("/com/cts/resources/applicationContext.xml");
		Student std = (Student) context.getBean("stdBean");
		std.getStudentDetails();
	}

}

Q)What are the difference between BeanFactory and ApplicationContext Containers?
---------------------------------------------------------------------------------
Ans:
-----
1. BeanFacotry is a fundamental container, it able to provide fundamental
functionalities to the Spring applications like creating bean objects and supplying bean
objects to Spring application.

ApplicationContext is an extension of BeanFactory, it able to perform the advanced
features like I18N, and Notification Model,.... along basic functionalities
what BeanFactory is providing.

2. BeanFactory is not supporting AOP module.

ApplicationContext is supporting AOP module.

3. BeanFactory is not suitable for Web applicaiton development with spring WEB MVC 
Module.

ApplicaitonContext is very much suitable for Web applicaiton development on the basis of 
Spring WEB MVC.

4. BeanFactory is able to create Bean Objects when we access getBean() method, that is,
Lazy instantiation / Initialization.

ApplicationContext is able to create Bean objects at the time of ApplicaitonContext
startup, that is, early Instantiation / Initialization.

5. BeanFactory is able to support the Scopes like Signgleton and Prototype.

 ApplicaitonContext is able to support the Scopes like singleton, prototype, request,
session, globalSession,....

6. BeanFactory is mainly for standalone applcaiton.

ApplicaitonContext is for any type of Spring applicaiton.

7. BeanFactory is outdated container in spring framework.

ApplicaitonContext is not outdated container.


Bean in Spring Framework:
--------------------------

1. Beans Defination
2. Beans configuration
3. Beans Scopes
4. Bean Lifecycle 
5. Beans Inheritance
6. Nested Beans
7. BeanPostProcessor


1. Beans Defination:
---------------------
--> Bean is a Reusable component, it is a normal java class, it will have
    1. Properties
    2. setXXX and getXXX methods for each and every properties
    3. Business Methods
    4. Event-Notificatio model
    5. Data vaidations
       ------
       ------
Rules and Regulation to use Beans in Spring:
1. In spring application, bean components must be POJJO classes, they must not implement 
   or extend predefined library except java.io.Serializable.
2. In Bean classes, we have to declare properties and we must provide a seperate set of
   setXXX() and getXXX() methods.
3. In sprign applicaitons, Bean classes must be public, non abstract and non final.
4. In spring framework, inside beans, all properties must be declared as private and all
   methods msut be declared as public.
5. In Bean class, if we want to decalre any construtor then it is possible to provide  
   public and 0-arg construtor.
6. If we want to provide our own comaprision between bean class then it is suggestable 
   to overide equals(--).
7. If we want to generate hashcode values to the Bean objects in our own view then we
   have to override hashCode() method.


2. Beans configuration:
-----------------------
--> We msut provide details of the bean classes to the containers inorder to 
instantiate.
1. XML based configuration
2. Annotation Based configuration
3. Java Based Configuration

1. XML based configuration:
----------------------------
If we provide beans details to the containers through an xml file then it is called as
XML configuration.

<beans ----->
   <bean id="--" name="--" class="--" scope="--">
    -----
   </bean>
</beans>

<bean> tag can be used to provide single bean configuration details.
id: it will provide an identity value for the bean object.
name: it will provide an identity or alias names to the bean object.
class: Fully qualified name of the Bean class.
scope: it can be used to specify a particular spring scope inorder to keep Bean objects.

Q) What is the difference between 'id' attribute and 'name' attribute?
-----------------------------------------------------------------------
Ans:
-----
'id' attribute will take single value that is identity for th e bean object inorder to
retrieve.

'name' attribute will take one or more no of values with, or; or space separator, if
 we provide more than one value then first value is treated as identity for the bean
object and the reamining values are treated  as alias names to the bean identity.

Note: In Bean configuration, we can provide bean class configuration with "name"
attribute and without "id" attribute.

Note: In spring configuration, in bean class configuration, we can provide both 'id'
attribute and 'name' attribute, where id attribute value is treated as bean identity and
'name' attribute values are treated as bean alias names.

Note: It is possible to get Bean objects on the basis of both identity and alias names.


where "class" attribute is able to take fully qualified name of the respective bean class.

where "scope" attribute will take a particular Spring scope.

Scopes in Spring Framework:
---------------------------
--> public, protected, <default>, private
--> Spring framework has provided 7 types of scopes to make available Bean objects and 
    to generate same or different bean objects for our Bean request.

1. Singltion Scope
2. Prototype Scope
3. Rerquest Scope
4. Session Scope
5. globalSession Scope
6. application Scope
7. webSocket Scope


1. Singltion Scope:
-------------------
--> It is default scope in spring applicaitons.
--> It will create a separate Bean object for each and every bean definition in Spring
    Configuration.

2. Prototype Scope:
--------------------
--> It is not default scope in Spring applications.
--> It allows to create a separate Bean object for each and every request for Bean, that 
    is, for each and every getBean() method call.

In Spring application, we able to define our own scope also.

ThreadLocal
--------------
private,  <default>, protected, public

ThreadScope: It will make available data upto how many no of resources[java methods]
which are accessed by the present Thread.

To implement ThreadScope in Java we have to use "ThreadLocal" class.

To define Custom Scope in Spring application we have to use the following steps.
1. Declare User Defined class
2. Implement Scope inteface and provide Scope interface methods in user defined class.
   1. get()
   2. remove()
   3. getConversationalId()
   4. registerDestrutionCallback()
   5. resolveContextualObject(String name)
3. Register User defined scope class in spring configuration file.
   1. Declare a property CustomScopeConfigure class as bean.
   2. Declare "scopes" as property in customScopeConfigure
   3. Decalre map under scopes property
   4. Declare Entry under map.
   5. In Entry, declare Scope name as Key and Scope Object as value in map.
4. Use custom Scope to the Bean Object:
   <bean name="stdBean" class="StudentBean" scope="threadScope" />




2. Annotation Based configuration
3. Java Based Configuration:
------------------------------
Upto Spring 2.4 version, it is manadatory to provide spring configuration file, but
from, Spring3.x version onwards, Spring configuratin file is optional, we can use
Spring configuration class as an alternatives for spring configuration file.

1. Create Bean classes as per the requirement.
2. Create Spring cofiguration class with the requirement methods by using the following 
   annotations.
   1. @Configuration
   2. @Bean
3. In Test class, in main() method use the follwing container class.
   AnnotaitonConfigApplicationContext ctx = new AnnotaionConfigApplicationContext(
   ConfigClass.class)
4. GET	Bean object.
   public Object getBean(Class c) / public Object getBean(String method_Name)
5. Access Business Method.

Spring [Core Module]
Example of Java Based Configuration
-------------------------------------
WelcomeBean.java
-----------------
package com.cts.beans;

public class WelcomeBean {
	private String name;
	static {
		System.out.println("WelcomeBean class loading......");
	}
	public WelcomeBean() {
		System.out.println("WelcomeBean class instantiation......");
	}
	public void setName(String name) {
		this.name = name;
	}
	
	public String getName() {
		return name;
	}
	public String getWelcomeMessage() {
		return "Hello "+name + " , Welcome to CTS";
	}
}

HelloBean.java
-----------------
package com.cts.beans;

public class HelloBean {
	private String name;
	static {
		System.out.println("HelloBean class loading......");
	}
	public HelloBean() {
		System.out.println("HelloBean class instantiation......");
	}
    public void setName(String name) {
		this.name = name;
	}
    public String getName() {
		return name;
	}
	public String sayHello() {
		return "Hello "+name+" , Good Morning";
		
	}
}

AppConfig.java
-----------------
package com.cts.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.cts.beans.HelloBean;
import com.cts.beans.WelcomeBean;

@Configuration
public class AppConfig {
	static {
		System.out.println("AppConfig class loading......");
	}
	public AppConfig() {
		System.out.println("AppConfig class instantiation......");
	}
	@Bean
	public WelcomeBean welcomeBean() {
		WelcomeBean wb = new WelcomeBean();
		wb.setName("Rahul");
		return wb;
	}
	
	@Bean
	public HelloBean helloBean() {
		HelloBean hb = new HelloBean();
		hb.setName("Rahul");
		return hb;
	}
}

Test.java
-----------------
package com.cts.test;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import com.cts.beans.HelloBean;
import com.cts.beans.WelcomeBean;
import com.cts.config.AppConfig;

public class Test {

	public static void main(String[] args) {
		ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
		String[] beanNames = context.getBeanDefinitionNames();
		for(String beanName : beanNames){
			System.out.println(beanName);
		}
//		WelcomeBean welBean1 = (WelcomeBean) context.getBean("welcomeBean");
//		System.out.println(welBean1.getWelcomeMessage());
//		WelcomeBean welBean2 = (WelcomeBean) context.getBean("welcomeBean");
//		System.out.println(welBean2.getWelcomeMessage());
//		System.out.println(welBean1);
//		System.out.println(welBean2);
//		System.out.println(welBean1 == welBean2);
		
		
//		HelloBean helloBean = (HelloBean) context.getBean("helloBean");
//		System.out.println(helloBean.sayHello());
	}

}


3. Beans Scopes--completed above
4. Bean Lifecycle 
5. Beans Inheritance
6. Nested Beans
7. BeanPostProcessor
